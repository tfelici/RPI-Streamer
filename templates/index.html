<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>System Stats - RPI Streamer</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    <style>
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            margin: 0;
        }
        
        .collapsible-header:hover {
            opacity: 0.8;
        }
        
        .collapse-icon {
            margin-right: 0.5rem;
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }
        
        .collapsible-content {
            transition: max-height 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        .collapsible-content:not(.collapsed) {
            max-height: 1000px;
            opacity: 1;
        }
          .collapsed + .collapsible-content .collapse-icon {
            transform: rotate(-90deg);
        }
        
        /* System Diagnostics Styles */
        .diagnostics-status {
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #808080;
            animation: pulse 2s infinite;
        }
        
        .status-dot.healthy {
            background-color: #28a745;
        }
        
        .status-dot.warning {
            background-color: #ffc107;
        }
        
        .status-dot.critical {
            background-color: #dc3545;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .diagnostics-alerts {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .diagnostics-alerts.critical {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
        
        .alert-section h4 {
            margin: 0 0 0.5rem 0;
            color: #856404;
            font-size: 1em;
        }
        
        .diagnostics-alerts.critical .alert-section h4 {
            color: #721c24;
        }
        
        .alert-section ul {
            margin: 0;
            padding-left: 1.2rem;
        }
        
        .alert-section li {
            margin: 0.25rem 0;
            color: #856404;
        }
        
        .diagnostics-alerts.critical .alert-section li {
            color: #721c24;
        }
        
        .diagnostics-details {
            margin-top: 1rem;
        }
        
        .details-toggle {
            margin: 0 0 1rem 0;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #007bff;
            font-size: 1em;
            transition: color 0.2s;
        }
        
        .details-toggle:hover {
            color: #0056b3;
        }
        
        .details-toggle .collapse-icon {
            transition: transform 0.3s ease;
        }
        
        .details-toggle.expanded .collapse-icon {
            transform: rotate(90deg);
        }
        
        .detailed-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .diagnostics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .diag-category {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .diag-category h5 {
            margin: 0 0 0.75rem 0;
            color: #495057;
            font-size: 1em;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 0.5rem;
        }
        
        .diag-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            font-size: 0.9em;
        }
        
        .diag-label {
            color: #6c757d;
            font-weight: 500;
        }
        
        .diag-value {
            font-family: 'Courier New', monospace;
            color: #495057;
            font-weight: bold;
        }
        
        .diag-value.error {
            color: #dc3545;
        }
        
        .diag-value.warning {
            color: #ffc107;
        }
    </style>
</head>

<body>
    {% set uploadrecordingsonly = request.args.get('uploadrecordingsonly') == '1' %}
    {% if not uploadrecordingsonly %}
    {% include 'navbar.html' %}
    {% endif %}

    <div class="container">
        {% if not uploadrecordingsonly %}        <!-- System Stats -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="system-stats-content">
                <span class="collapse-icon">▼</span>
                System Statistics
            </h2>
            <div id="system-stats-content" class="collapsible-content">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="cpu">--</span>
                        <div class="stat-label">CPU Usage (%)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="mem">--</span>
                        <div class="stat-label">Memory Usage (%)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="temp">--</span>
                        <div class="stat-label">Temperature</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="power">--</span>
                        <div class="stat-label">Power Draw</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Network Connection -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="network-content">
                <span class="collapse-icon">▼</span>
                Network Connection
            </h2>
            <div id="network-content" class="collapsible-content">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="ethernet">--</span>
                        <div class="stat-label">Ethernet</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="wifi">--</span>
                        <div class="stat-label">WiFi</div>
                    </div>
                </div>

                <!-- WiFi Details Section -->
                <div id="wifi-details" style="margin-top: 1rem; display: none;">
                    <h3>WiFi Details</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-signal">--</span>
                            <div class="stat-label">Signal Strength</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-tx-bitrate">--</span>
                            <div class="stat-label">TX Bitrate</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-rx-bitrate">--</span>
                            <div class="stat-label">RX Bitrate</div>
                        </div>
                    </div>
                </div>

                <!-- IP Addresses Section -->
                <div id="ip-addresses" style="margin-top: 1rem; display: none;">
                    <h3>IP Addresses</h3>
                    <div id="ip-list" class="ip-list">
                        <!-- IP addresses will be populated here -->
                    </div>
                </div>
            </div>        </div>

        <!-- System Diagnostics -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="diagnostics-content">
                <span class="collapse-icon">▼</span>
                System Diagnostics
            </h2>
            <div id="diagnostics-content" class="collapsible-content">
                <div class="diagnostics-status" id="diagnostics-status">
                    <div class="status-indicator" id="diagnostics-health">
                        <span class="status-dot"></span>
                        <span id="health-text">Checking...</span>
                    </div>
                </div>
                
                <!-- Throttling/Undervoltage Alerts -->
                <div id="diagnostics-alerts" class="diagnostics-alerts" style="display: none;">
                    <div class="alert-section">
                        <h4>Current Issues</h4>
                        <ul id="current-issues"></ul>
                    </div>
                    <div class="alert-section">
                        <h4>Past Issues</h4>
                        <ul id="past-issues"></ul>
                    </div>
                </div>

                <!-- Detailed Diagnostics (collapsible) -->
                <div class="diagnostics-details">
                    <h4 class="details-toggle" id="details-toggle">
                        <span class="collapse-icon">▶</span>
                        Detailed Information
                    </h4>
                    <div id="detailed-diagnostics" class="detailed-content" style="display: none;">
                        <div class="diagnostics-grid">
                            <!-- Temperature & Voltages -->
                            <div class="diag-category">
                                <h5>Temperature & Voltages</h5>
                                <div class="diag-item">
                                    <span class="diag-label">Temperature:</span>
                                    <span class="diag-value" id="diag-temperature">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Core Voltage:</span>
                                    <span class="diag-value" id="diag-voltage-core">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">SDRAM C Voltage:</span>
                                    <span class="diag-value" id="diag-voltage-sdram-c">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">SDRAM I Voltage:</span>
                                    <span class="diag-value" id="diag-voltage-sdram-i">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">SDRAM P Voltage:</span>
                                    <span class="diag-value" id="diag-voltage-sdram-p">--</span>
                                </div>
                            </div>

                            <!-- UPS Status -->
                            <div class="diag-category">
                                <h5>UPS Status</h5>
                                <div class="diag-item">
                                    <span class="diag-label">UPS Voltage:</span>
                                    <span class="diag-value" id="diag-ups-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Capacity:</span>
                                    <span class="diag-value" id="diag-ups-capacity">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Status:</span>
                                    <span class="diag-value" id="diag-ups-battery-status">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">AC Power:</span>
                                    <span class="diag-value" id="diag-ups-ac-power">--</span>
                                </div>
                            </div>

                            <!-- Clock Frequencies -->
                            <div class="diag-category">
                                <h5>Clock Frequencies</h5>
                                <div class="diag-item">
                                    <span class="diag-label">ARM:</span>
                                    <span class="diag-value" id="diag-clock-arm">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Core:</span>
                                    <span class="diag-value" id="diag-clock-core">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">H264:</span>
                                    <span class="diag-value" id="diag-clock-h264">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">ISP:</span>
                                    <span class="diag-value" id="diag-clock-isp">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">V3D:</span>
                                    <span class="diag-value" id="diag-clock-v3d">--</span>
                                </div>
                            </div>

                            <!-- Memory Split -->
                            <div class="diag-category">
                                <h5>Memory Split</h5>
                                <div class="diag-item">
                                    <span class="diag-label">ARM Memory:</span>
                                    <span class="diag-value" id="diag-mem-arm">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">GPU Memory:</span>
                                    <span class="diag-value" id="diag-mem-gpu">--</span>
                                </div>
                            </div>

                            <!-- Codecs -->
                            <div class="diag-category">
                                <h5>Hardware Codecs</h5>
                                <div class="diag-item">
                                    <span class="diag-label">H264:</span>
                                    <span class="diag-value" id="diag-codec-h264">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">MPG2:</span>
                                    <span class="diag-value" id="diag-codec-mpg2">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">WVC1:</span>
                                    <span class="diag-value" id="diag-codec-wvc1">--</span>
                                </div>
                            </div>

                            <!-- INA219 Power Monitoring -->
                            <div class="diag-category">
                                <h5>Power Monitoring (INA219)</h5>
                                <div class="diag-item">
                                    <span class="diag-label">Bus Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-bus-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Shunt Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-shunt-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Current:</span>
                                    <span class="diag-value" id="diag-ina219-current">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Power:</span>
                                    <span class="diag-value" id="diag-ina219-power">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">PSU Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-psu-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Power Source:</span>
                                    <span class="diag-value" id="diag-ina219-power-source">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Level:</span>
                                    <span class="diag-value" id="diag-ina219-battery-percent">--</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stream Control -->
        <div class="frame" id="stream-panel">
            <h2>Stream Control</h2>
            <div style="text-align: center; margin-bottom: 1.5rem;">
                <button id="stream-btn" class="btn btn-primary">
                    {{ 'Stop Streaming' if streaming else 'Start Streaming' }}
                </button>
            </div>
            <div id="stream-status" class="status-message" style="display: none;"></div>

            <!-- Streaming Information Panel -->
            <div id="streaming-info-panel" style="margin-top: 1rem; display: {{ 'block' if streaming else 'none' }};">
                <h3>Streaming Information</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="stream-bitrate">--</span>
                        <div class="stat-label">Bitrate (kbps)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stream-measured-bitrate">--</span>
                        <div class="stat-label">Measured Bitrate (kbps)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="stream-network-status">--</span>
                        <div class="stat-label">Network Status</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="stream-health">--</span>
                        <div class="stat-label">Stream Health</div>
                    </div>
                </div>
            </div>

            <!-- Active Recordings Panel -->
            <div id="active-recordings-frame" style="margin-top: 2rem; display: none;">
                <h2>Active Recordings</h2>
                <div class="file-list" id="active-recordings-list"></div>
            </div>
        </div>
        {% endif %}

        <!-- Upload Recordings -->
        {% if (recording_files and not streaming) or uploadrecordingsonly %}
        <div class="frame" id="upload-frame">
            <h2>Upload Recordings</h2>
            <form id="upload-form">
                <div class="file-list">
                    {% if recording_files %}
                    {% for file in recording_files if not file.active %}
                    <div class="file-item">
                        <input type="checkbox" class="upload-checkbox file-checkbox" id="recfile{{ loop.index }}"
                            name="recording_files" value="{{ file.path }}" checked>
                        <label for="recfile{{ loop.index }}" class="file-info" data-info='{{ {'timestamp':
                            file.timestamp, 'duration' : file.duration}|tojson|safe }}'>
                            <strong>Timestamp:</strong> {{ file.timestamp | datetimeformat }}<br>
                            <strong>Duration:</strong> {{ file.duration | durationformat }}<br>
                            <strong>Size:</strong> {{ file.size | filesizeformat }}<br>
                            <strong>Bitrate:</strong> {% if file.duration and file.duration > 0 %}{{ ((file.size * 8) // file.duration // 1000) }} kbps{% else %}--{% endif %}<br>
                            <strong>Location:</strong> {{ file.location }}
                        </label>
                    </div>
                    {% endfor %}
                    {% else %}
                    <div class="file-item">
                        <p>No recordings available for upload.</p>
                    </div>
                    {% endif %}
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap;">
                    <button type="submit" id="upload-btn" class="btn btn-success">Upload to Server</button>
                    <button type="button" id="move-to-usb-btn" class="btn btn-primary">Move to USB Drive</button>
                    <button type="button" id="delete-btn" class="btn btn-danger">Delete Selected</button>
                </div>
                <div id="upload-result" style="margin-top: 1.5rem;"></div>
            </form>
        </div>
        {% endif %}
    </div>

    <script>
        // Ensure streaming variable is available before any script uses it
        // eslint-disable-next-line no-unused-vars, no-undef
        var streaming = {{ streaming | tojson | safe }};
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const uploadForm = document.getElementById('upload-form');
            const uploadBtn = document.getElementById('upload-btn');
            const uploadResult = document.getElementById('upload-result');
            if (uploadForm) {
                let resultList = document.createElement('ul');
                resultList.style.textAlign = 'left';
                uploadResult.innerHTML = '';
                uploadResult.appendChild(resultList);
                uploadForm.onsubmit = async function (e) {
                    e.preventDefault();
                    resultList.innerHTML = '';
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        resultList.innerHTML = '<li style="color:red;">No recordings selected.</li>';
                        return;
                    }

                    // Filter out files that are already uploading
                    const filesToUpload = [];
                    const skippedFiles = [];

                    for (const checkbox of checkboxes) {
                        const filePath = checkbox.value;
                        const fileItemDiv = checkbox.closest('.file-item');
                        const existingContainer = fileItemDiv.querySelector('.upload-progress-container');

                        if (existingContainer) {
                            skippedFiles.push(filePath.split(/[/\\]/).pop() || filePath);
                        } else {
                            filesToUpload.push(checkbox);
                        }
                    }

                    if (skippedFiles.length > 0) {
                        const li = document.createElement('li');
                        li.style.color = 'orange';
                        li.textContent = `Skipped ${skippedFiles.length} file(s) already uploading: ${skippedFiles.join(', ')}`;
                        resultList.appendChild(li);
                    }

                    if (filesToUpload.length === 0) {
                        return;
                    }

                    let successCount = 0;
                    const activeUploads = [];
                    for (let i = 0; i < filesToUpload.length; i++) {
                        const checkbox = filesToUpload[i];
                        const filePath = checkbox.value;
                        const fileName = filePath.split(/[/\\]/).pop() || filePath;
                        // Find the file-item div for this checkbox
                        const fileItemDiv = checkbox.closest('.file-item');

                        // Create upload progress container within the file-item
                        const uploadContainer = document.createElement('div');
                        uploadContainer.className = 'upload-progress-container';
                        uploadContainer.style.marginTop = '0.5rem';
                        uploadContainer.style.padding = '0.5rem';
                        uploadContainer.style.backgroundColor = '#f8f9fa';
                        uploadContainer.style.border = '1px solid #dee2e6';
                        uploadContainer.style.borderRadius = '4px';
                        const statusText = document.createElement('div');
                        statusText.textContent = `Uploading ${fileName}... (${i + 1}/${filesToUpload.length})`;
                        statusText.style.marginBottom = '0.5rem';
                        uploadContainer.appendChild(statusText);

                        const progressContainer = document.createElement('div');
                        progressContainer.style.display = 'flex';
                        progressContainer.style.alignItems = 'center';
                        progressContainer.style.gap = '0.5rem';

                        const progress = document.createElement('progress');
                        progress.value = 0;
                        progress.max = 100;
                        progress.style.width = '200px';
                        progress.style.height = '20px';
                        progressContainer.appendChild(progress);

                        const cancelBtn = document.createElement('button');
                        cancelBtn.textContent = 'Cancel';
                        cancelBtn.type = 'button';
                        cancelBtn.className = 'btn btn-sm btn-danger';
                        cancelBtn.style.padding = '0.25rem 0.5rem';
                        cancelBtn.style.fontSize = '0.875rem';
                        progressContainer.appendChild(cancelBtn);

                        uploadContainer.appendChild(progressContainer);
                        fileItemDiv.appendChild(uploadContainer);

                        // Start the upload
                        const formData = new FormData();
                        formData.append('file_path', filePath);

                        try {
                            const response = await fetch('/upload-recording', {
                                method: 'POST',
                                body: formData
                            });

                            const result = await response.json();
                            if (result.error) {
                                statusText.style.color = 'red';
                                statusText.textContent = `Error uploading ${fileName}: ${result.error}`;
                                uploadContainer.remove();
                                continue;
                            }

                            const uploadId = result.upload_id;
                            let cancelled = false;
                            // Set up cancel button
                            cancelBtn.onclick = async function () {
                                cancelled = true;
                                try {
                                    await fetch(`/cancel-upload/${uploadId}`, { method: 'POST' });
                                    statusText.style.color = 'red';
                                    statusText.textContent = `Upload cancelled: ${fileName}`;
                                    uploadContainer.remove();
                                    // Remove from active uploads immediately
                                    const index = activeUploads.indexOf(uploadId);
                                    if (index > -1) activeUploads.splice(index, 1);
                                } catch (e) {
                                    console.error('Error cancelling upload:', e);
                                }
                            };

                            // Use SSE for real-time progress monitoring
                            let eventSource = null;

                            const startProgressMonitoring = () => {
                                if (cancelled) return;

                                eventSource = new EventSource(`/upload-progress-stream/${uploadId}`);

                                eventSource.onmessage = function (event) {
                                    if (cancelled) {
                                        eventSource.close();
                                        return;
                                    }

                                    try {
                                        const progressData = JSON.parse(event.data);

                                        if (progressData.type === 'connected') {
                                            console.log(`SSE connected for upload ${uploadId}`);
                                            return;
                                        }

                                        if (progressData.type === 'closed') {
                                            eventSource.close();
                                            return;
                                        }
                                        if (progressData.type === 'progress') {
                                            if (progressData.error) {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Error uploading ${fileName}: ${progressData.error}`;
                                                uploadContainer.remove();
                                                eventSource.close();
                                                return;
                                            }

                                            // Update progress bar
                                            progress.value = progressData.progress || 0;

                                            if (progressData.status === 'completed') {
                                                const uploadResult = progressData.result;
                                                if (uploadResult && uploadResult.error) {
                                                    statusText.style.color = 'red';
                                                    statusText.textContent = `Error uploading ${fileName}: ${uploadResult.error}`;
                                                } else {
                                                    statusText.style.color = 'green';
                                                    let replacedMsg = '';
                                                    if (uploadResult && typeof uploadResult.files_replaced !== 'undefined') {
                                                        replacedMsg = ` (${uploadResult.files_replaced} file${uploadResult.files_replaced == 1 ? '' : 's'} replaced on server)`;
                                                    }
                                                    statusText.textContent = `Uploaded ${fileName}: Success.` + replacedMsg;
                                                    successCount++;
                                                    // Remove the checkbox since upload succeeded
                                                    const checkboxDiv = checkbox.closest('div');
                                                    if (checkboxDiv) checkboxDiv.remove();
                                                }
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);

                                                // Check if all uploads are done
                                                if (activeUploads.length === 0) {
                                                    const summary = document.createElement('li');
                                                    summary.style.color = 'green';
                                                    summary.textContent = `Successfully uploaded ${successCount} file(s).`;
                                                    resultList.appendChild(summary);

                                                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                                                        uploadBtn.remove();
                                                        const moveToUsbBtn = document.getElementById('move-to-usb-btn');
                                                        if (moveToUsbBtn) moveToUsbBtn.remove();
                                                    }
                                                }
                                            } else if (progressData.status === 'error') {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Error uploading ${fileName}: ${progressData.error}`;
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);
                                            } else if (progressData.status === 'cancelled') {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Upload cancelled: ${fileName}`;
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);
                                            }
                                            // For 'uploading' status, just continue receiving updates
                                        }
                                    } catch (e) {
                                        console.error('Error parsing SSE data:', e);
                                    }
                                };
                                eventSource.onerror = function (event) {
                                    console.error('SSE error:', event);
                                    if (!cancelled) {
                                        statusText.style.color = 'red';
                                        statusText.textContent = `Error uploading ${fileName}: Connection lost`;
                                        uploadContainer.remove();
                                        // Remove from active uploads
                                        const index = activeUploads.indexOf(uploadId);
                                        if (index > -1) activeUploads.splice(index, 1);
                                    }
                                    eventSource.close();
                                };
                            };

                            // Add to active uploads and start SSE monitoring
                            activeUploads.push(uploadId);
                            startProgressMonitoring();
                        } catch (e) {
                            statusText.style.color = 'red';
                            statusText.textContent = `Error uploading ${fileName}: ${e.message}`;
                            uploadContainer.remove();
                        }
                    }
                };
            }

            async function getUploadServerUrl() {
                try {
                    const resp = await fetch('/settings');
                    const data = await resp.json();
                    return data.upload_url || '';
                } catch (e) {
                    return '';
                }
            } async function fetchOverlappingInfo(uploadUrl, file, duration) {
                if (!uploadUrl) return null;
                // Handle both Windows and Unix path separators
                const filename = file.split(/[/\\]/).pop();
                let url = new URL(uploadUrl);
                url.searchParams.set('command', 'getrecordingsinfo');
                url.searchParams.set('videofilename', filename);
                url.searchParams.set('duration', duration);
                try {
                    const response = await fetch(url, { method: 'GET' });
                    if (!response.ok) throw new Error('Network response was not ok. URL: ' + url.toString());
                    return await response.json();
                } catch (e) {
                    return { error: e.message + ' (URL: ' + url.toString() + ')' };
                }
            }

            (async function () {
                const uploadUrl = await getUploadServerUrl();
                const checkboxes = document.querySelectorAll('.upload-checkbox');
                for (const checkbox of checkboxes) {
                    const file = checkbox.value;
                    const label = document.querySelector(`label[for="${checkbox.id}"]`);
                    if (!file || !label) continue;
                    const loadingDiv = document.createElement('div');
                    loadingDiv.style.fontSize = '0.9em';
                    loadingDiv.style.color = '#888';
                    loadingDiv.textContent = 'Checking server for overlapping files...';
                    label.appendChild(loadingDiv);
                    loadingDiv.remove();
                    let localInfo = null;
                    try {
                        localInfo = JSON.parse(label.getAttribute('data-info'));
                    } catch (e) { }
                    const info = await fetchOverlappingInfo(uploadUrl, file, localInfo ? localInfo.duration : 0);
                    if (info && info.overlapping_files && info.overlapping_files.length > 0 && localInfo) {
                        const barWidth = 220;
                        const barHeight = 18;
                        const barColor = "#eee";
                        const borderColor = "#bbb";
                        const overlapColor = "#d33";
                        const localStart = Number(localInfo.timestamp);
                        const localDuration = Number(localInfo.duration);
                        const localEnd = localStart + localDuration;
                        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        svg.setAttribute("width", barWidth);
                        svg.setAttribute("height", barHeight);
                        svg.style.display = "block";
                        svg.style.margin = "8px 0";
                        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bg.setAttribute("x", 0);
                        bg.setAttribute("y", 2);
                        bg.setAttribute("width", barWidth);
                        bg.setAttribute("height", barHeight - 4);
                        bg.setAttribute("fill", barColor);
                        bg.setAttribute("stroke", borderColor);
                        bg.setAttribute("stroke-width", 1);
                        svg.appendChild(bg);
                        info.overlapping_files.forEach(f => {
                            const overlapStart = Math.max(Number(f.timestamp), localStart);
                            const overlapEnd = Math.min(Number(f.timestamp) + Number(f.duration), localEnd);
                            if (overlapEnd > overlapStart) {
                                const x = ((overlapStart - localStart) / localDuration) * barWidth;
                                const w = ((overlapEnd - overlapStart) / localDuration) * barWidth;
                                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                rect.setAttribute("x", x);
                                rect.setAttribute("y", 2);
                                rect.setAttribute("width", w);
                                rect.setAttribute("height", barHeight - 4);
                                rect.setAttribute("fill", overlapColor);
                                rect.setAttribute("opacity", 0.8);
                                svg.appendChild(rect);
                            }
                        });
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#b00';
                        div.innerHTML = 'Overlapping server files:';
                        div.appendChild(svg);
                        const overlaps = info.overlapping_files.map(f =>
                            `Server file: ${f.timestamp} (${f.duration}s, ${f.size_mb} MB)`
                        ).join('<br>');
                        const textDiv = document.createElement('div');
                        textDiv.innerHTML = overlaps;
                        div.appendChild(textDiv);
                        label.appendChild(div);
                    } else if (info && info.error) {
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#b00';
                        div.textContent = 'Error: ' + info.error;
                        label.appendChild(div);
                    } else {
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#080';
                        div.textContent = 'No overlapping files on server.';
                        label.appendChild(div);
                    }
                }
            })();
        });
    </script>    {% if not uploadrecordingsonly %}
    <script>
        // Collapsible panels functionality
        function initializeCollapsiblePanels() {
            const headers = document.querySelectorAll('.collapsible-header');
            
            headers.forEach(header => {
                const targetId = header.getAttribute('data-target');
                const content = document.getElementById(targetId);
                const icon = header.querySelector('.collapse-icon');
                
                if (!content) return;
                
                // Get saved state from localStorage (default to collapsed)
                const savedState = localStorage.getItem(`panel-${targetId}`);
                const isCollapsed = savedState === null ? true : savedState === 'collapsed';
                
                // Apply initial state
                if (isCollapsed) {
                    content.classList.add('collapsed');
                    icon.style.transform = 'rotate(-90deg)';
                } else {
                    content.classList.remove('collapsed');
                    icon.style.transform = 'rotate(0deg)';
                }
                
                // Add click handler
                header.addEventListener('click', function() {
                    const isCurrentlyCollapsed = content.classList.contains('collapsed');
                    
                    if (isCurrentlyCollapsed) {
                        content.classList.remove('collapsed');
                        icon.style.transform = 'rotate(0deg)';
                        localStorage.setItem(`panel-${targetId}`, 'expanded');
                    } else {
                        content.classList.add('collapsed');
                        icon.style.transform = 'rotate(-90deg)';
                        localStorage.setItem(`panel-${targetId}`, 'collapsed');
                    }
                });
            });
        }
          // Initialize collapsible panels when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeCollapsiblePanels);
        
        // System Diagnostics functionality
        let diagnosticsEventSource = null;
        
        function initializeDiagnostics() {
            // Handle detailed diagnostics toggle
            const detailsToggle = document.getElementById('details-toggle');
            const detailedDiagnostics = document.getElementById('detailed-diagnostics');
            
            if (detailsToggle && detailedDiagnostics) {
                detailsToggle.addEventListener('click', function() {
                    const isExpanded = detailedDiagnostics.style.display !== 'none';
                    
                    if (isExpanded) {
                        detailedDiagnostics.style.display = 'none';
                        detailsToggle.classList.remove('expanded');
                    } else {
                        detailedDiagnostics.style.display = 'block';
                        detailsToggle.classList.add('expanded');
                    }
                });
            }
            
            // Start SSE connection for diagnostics
            startDiagnosticsRefresh();
        }
        
        function startDiagnosticsRefresh() {
            if (diagnosticsEventSource) {
                diagnosticsEventSource.close();
            }
            
            diagnosticsEventSource = new EventSource('/diagnostics-sse');
            
            diagnosticsEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateDiagnosticsDisplay(data);
                } catch (e) {
                    console.error('Error parsing diagnostics data:', e);
                }
            };
            
            diagnosticsEventSource.onerror = function() {
                console.error('Diagnostics SSE connection error');
                // Try to reconnect after 5 seconds
                setTimeout(() => {
                    if (diagnosticsEventSource.readyState === EventSource.CLOSED) {
                        startDiagnosticsRefresh();
                    }
                }, 5000);
            };
        }
        
        function stopDiagnosticsRefresh() {
            if (diagnosticsEventSource) {
                diagnosticsEventSource.close();
                diagnosticsEventSource = null;
            }
        }
        
        function updateDiagnosticsDisplay(data) {
            // Update health status
            const healthText = document.getElementById('health-text');
            const statusDot = document.querySelector('.status-dot');
            const alertsDiv = document.getElementById('diagnostics-alerts');
            const currentIssuesList = document.getElementById('current-issues');
            const pastIssuesList = document.getElementById('past-issues');
            
            if (data.error) {
                if (healthText) healthText.textContent = `Error: ${data.error}`;
                if (statusDot) {
                    statusDot.className = 'status-dot critical';
                }
                return;
            }
            
            // Parse throttled status
            const throttledInfo = data.throttled_parsed || {};
            const hasIssues = throttledInfo.has_issues || false;
            const currentIssues = throttledInfo.current_issues || [];
            const pastIssues = throttledInfo.past_issues || [];
            
            // Update health indicator
            if (healthText && statusDot) {
                if (currentIssues.length > 0) {
                    healthText.textContent = 'Critical Issues Detected';
                    statusDot.className = 'status-dot critical';
                } else if (pastIssues.length > 0) {
                    healthText.textContent = 'Past Issues Detected';
                    statusDot.className = 'status-dot warning';
                } else {
                    healthText.textContent = 'System Healthy';
                    statusDot.className = 'status-dot healthy';
                }
            }
            
            // Update alerts section
            if (alertsDiv && currentIssuesList && pastIssuesList) {
                if (currentIssues.length > 0 || pastIssues.length > 0) {
                    alertsDiv.style.display = 'block';
                    alertsDiv.className = currentIssues.length > 0 ? 'diagnostics-alerts critical' : 'diagnostics-alerts';
                    
                    // Update current issues
                    currentIssuesList.innerHTML = '';
                    if (currentIssues.length > 0) {
                        currentIssues.forEach(issue => {
                            const li = document.createElement('li');
                            li.textContent = issue;
                            currentIssuesList.appendChild(li);
                        });
                    } else {
                        const li = document.createElement('li');
                        li.textContent = 'None';
                        li.style.fontStyle = 'italic';
                        currentIssuesList.appendChild(li);
                    }
                    
                    // Update past issues
                    pastIssuesList.innerHTML = '';
                    if (pastIssues.length > 0) {
                        pastIssues.forEach(issue => {
                            const li = document.createElement('li');
                            li.textContent = issue;
                            pastIssuesList.appendChild(li);
                        });
                    } else {
                        const li = document.createElement('li');
                        li.textContent = 'None';
                        li.style.fontStyle = 'italic';
                        pastIssuesList.appendChild(li);
                    }
                } else {
                    alertsDiv.style.display = 'none';
                }
            }
            
            // Update detailed diagnostics
            updateDetailedDiagnostics(data);
        }
        
        function updateDetailedDiagnostics(data) {
            // Temperature & Voltages
            updateDiagValue('diag-temperature', data.temperature);
            updateDiagValue('diag-voltage-core', data.voltage_core);
            updateDiagValue('diag-voltage-sdram-c', data.voltage_sdram_c);
            updateDiagValue('diag-voltage-sdram-i', data.voltage_sdram_i);
            updateDiagValue('diag-voltage-sdram-p', data.voltage_sdram_p);
            
            // UPS Status
            updateDiagValue('diag-ups-voltage', data.ups_voltage ? data.ups_voltage.toFixed(2) + 'V' : null);
            updateDiagValue('diag-ups-capacity', data.ups_capacity ? data.ups_capacity.toFixed(1) + '%' : null);
            updateDiagValue('diag-ups-battery-status', data.ups_battery_status);
            updateDiagValue('diag-ups-ac-power', data.ups_ac_power !== null ? (data.ups_ac_power ? 'Plugged In' : 'Unplugged') : null);
            
            // Clock Frequencies
            updateDiagValue('diag-clock-arm', data.clock_arm);
            updateDiagValue('diag-clock-core', data.clock_core);
            updateDiagValue('diag-clock-h264', data.clock_h264);
            updateDiagValue('diag-clock-isp', data.clock_isp);
            updateDiagValue('diag-clock-v3d', data.clock_v3d);
            
            // Memory Split
            updateDiagValue('diag-mem-arm', data.mem_arm);
            updateDiagValue('diag-mem-gpu', data.mem_gpu);
            
            // Codecs
            updateDiagValue('diag-codec-h264', data.codec_h264);
            updateDiagValue('diag-codec-mpg2', data.codec_mpg2);
            updateDiagValue('diag-codec-wvc1', data.codec_wvc1);
            
            // INA219 Power Monitoring
            updateDiagValue('diag-ina219-bus-voltage', data.ina219_bus_voltage);
            updateDiagValue('diag-ina219-shunt-voltage', data.ina219_shunt_voltage);
            updateDiagValue('diag-ina219-current', data.ina219_current);
            updateDiagValue('diag-ina219-power', data.ina219_power);
            updateDiagValue('diag-ina219-psu-voltage', data.ina219_psu_voltage);
            updateDiagValue('diag-ina219-power-source', data.ina219_power_source);
            updateDiagValue('diag-ina219-battery-percent', data.ina219_battery_percent);
        }
        
        function updateDiagValue(elementId, value) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = value || '--';
                
                // Add styling based on content
                element.className = 'diag-value';
                if (typeof value === 'string') {
                    if (value.includes('Error') || value.includes('not found') || value.includes('Timeout')) {
                        element.classList.add('error');
                    } else if (value.includes('disabled') || value === 'N/A') {
                        element.classList.add('warning');
                    }
                }
            }
        }
        
        // Initialize diagnostics when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeDiagnostics);
        
        const cpu = document.getElementById('cpu');
        const mem = document.getElementById('mem');
        const temp = document.getElementById('temp');
        const power = document.getElementById('power');
        const ethernet = document.getElementById('ethernet');
        const wifi = document.getElementById('wifi');
        const ipAddressesDiv = document.getElementById('ip-addresses');
        const ipList = document.getElementById('ip-list');
        const wifiDetailsDiv = document.getElementById('wifi-details');
        const wifiSignal = document.getElementById('wifi-signal');
        const wifiTxBitrate = document.getElementById('wifi-tx-bitrate');
        const wifiRxBitrate = document.getElementById('wifi-rx-bitrate');

        const evtSource = new EventSource('/stats');
        evtSource.onmessage = function (event) {
            const data = JSON.parse(event.data);
            cpu.textContent = data.cpu;
            mem.textContent = data.mem;
            temp.textContent = data.temp;
            power.textContent = data.power;

            // Handle connection information
            if (data.connection) {
                try {
                    const connection = JSON.parse(data.connection);

                    // Update ethernet and wifi status
                    ethernet.textContent = connection.ethernet || 'Disconnected';
                    wifi.textContent = connection.wifi || 'Disconnected';

                    // Update WiFi details if available
                    // Show panel if WiFi is connected, even if details are temporarily unavailable
                    const isWifiConnected = connection.wifi && connection.wifi !== 'Disconnected' && !connection.wifi.includes('Error');
                    
                    if (isWifiConnected) {
                        wifiDetailsDiv.style.display = 'block';
                        
                        // Signal strength
                        if (connection.wifi_details && connection.wifi_details.signal_percent !== undefined) {
                            const signalPercent = connection.wifi_details.signal_percent;
                            const signalDbm = connection.wifi_details.signal_dbm || '';
                            wifiSignal.textContent = `${signalPercent}%${signalDbm ? ` (${signalDbm} dBm)` : ''}`;
                            
                            // Color code signal strength
                            if (signalPercent >= 70) {
                                wifiSignal.style.color = '#28a745'; // green
                            } else if (signalPercent >= 40) {
                                wifiSignal.style.color = '#ffc107'; // yellow
                            } else {
                                wifiSignal.style.color = '#dc3545'; // red
                            }
                        } else {
                            wifiSignal.textContent = '--';
                            wifiSignal.style.color = '';
                        }
                        
                        // TX Bitrate
                        if (connection.wifi_details && connection.wifi_details.tx_bitrate !== undefined) {
                            wifiTxBitrate.textContent = `${connection.wifi_details.tx_bitrate} Mbps`;
                        } else {
                            wifiTxBitrate.textContent = '--';
                        }
                        
                        // RX Bitrate
                        if (connection.wifi_details && connection.wifi_details.rx_bitrate !== undefined) {
                            wifiRxBitrate.textContent = `${connection.wifi_details.rx_bitrate} Mbps`;
                        } else {
                            wifiRxBitrate.textContent = '--';
                        }
                    } else {
                        wifiDetailsDiv.style.display = 'none';
                        wifiSignal.textContent = '--';
                        wifiTxBitrate.textContent = '--';
                        wifiRxBitrate.textContent = '--';
                        wifiSignal.style.color = '';
                    }

                    // Update IP addresses
                    if (connection.ip_addresses && connection.ip_addresses.length > 0) {
                        ipAddressesDiv.style.display = 'block';
                        ipList.innerHTML = '';

                        connection.ip_addresses.forEach(function (ipInfo) {
                            const ipItem = document.createElement('div');
                            ipItem.className = 'ip-item';
                            ipItem.innerHTML = '<span class="ip-address">' + ipInfo.ip + '</span> <small>(' + ipInfo.interface + ')</small>';
                            ipList.appendChild(ipItem);
                        });
                    } else {
                        ipAddressesDiv.style.display = 'none';
                    }
                } catch (e) {
                    console.error('Error parsing connection data:', e);
                    ethernet.textContent = 'Error';
                    wifi.textContent = 'Error';
                    wifiDetailsDiv.style.display = 'none';
                }
            }
        };

        // --- Active Recordings Panel Auto-Refresh ---
        function renderActiveRecordingsPanel(files) {
            let frame = document.getElementById('active-recordings-frame');
            if (!frame) return;
            // Show/hide the panel based on streaming/active files
            if ((!files || files.length === 0) && !streaming) {
                frame.style.display = 'none';
                return;
            }
            frame.style.display = '';
            const listDiv = frame.querySelector('#active-recordings-list');
            listDiv.innerHTML = '';
            if (files && files.length > 0) {
                files.forEach((file, idx) => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '0.5em';
                    // Use timestamp from file object directly
                    let durationStr = '--';
                    let bitrateStr = '--';
                    let filesizeStr = '--';
                    if (file.size) {
                        filesizeStr = file.size + ' bytes';
                        if (file.size >= 1024 * 1024) {
                            filesizeStr = (file.size / (1024 * 1024)).toFixed(2) + ' MB';
                        } else if (file.size >= 1024) {
                            filesizeStr = (file.size / 1024).toFixed(2) + ' KB';
                        }
                    }
                    let duration = null;
                    const now = Math.floor(Date.now() / 1000);
                    if (file.timestamp && now > file.timestamp) {
                        duration = now - file.timestamp;
                        durationStr = duration + 's';
                    }
                    // Calculate bitrate as filesize / duration
                    if (duration && duration > 0 && file.size) {
                        const bitrate = Math.round((file.size * 8) / duration / 1000);
                        bitrateStr = `${bitrate} kbps`;
                    }
                    div.innerHTML = `<label style="word-break:break-all;"><b>Active recording:</b> ${file.name}<br>Size: ${filesizeStr}<br>Duration: ${durationStr}<br>Bitrate: ${bitrateStr}<br>Location: ${file.location}</label>`;
                    listDiv.appendChild(div);
                });
            } else if (streaming) {
                const div = document.createElement('div');
                div.style.marginBottom = '0.5em';
                div.innerHTML = '<label>No active recordings yet. Streaming is running...</label>';
                listDiv.appendChild(div);
            }
        }
        let activeRecordingsEventSource = null;
        let streamingStatusEventSource = null;

        function startActiveRecordingsRefresh() {
            // Use SSE for real-time updates
            if (activeRecordingsEventSource) {
                activeRecordingsEventSource.close();
            }
            activeRecordingsEventSource = new EventSource('/active-recordings-sse');
            activeRecordingsEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    const files = data.files || [];
                    renderActiveRecordingsPanel(files);
                } catch (e) { }
            };
            activeRecordingsEventSource.onerror = function() {
                //SEE has terminated, stop the refresh
                stopActiveRecordingsRefresh();
                const frame = document.getElementById('active-recordings-frame');
                if (frame) frame.style.display = 'none'; // Hide instead of remove
            };
        }

        function stopActiveRecordingsRefresh() {
            if (activeRecordingsEventSource) {
                activeRecordingsEventSource.close();
                activeRecordingsEventSource = null;
            }
        }
        
        // Always start the active recordings refresh if streaming is active
        if (streaming) {
            startActiveRecordingsRefresh();
            startStreamingStatusRefresh();
        }        // Streaming status functionality
        function updateStreamStatusWithRelayInfo(relayData) {
            try {
                // Update bitrate
                const bitrateEl = document.getElementById('stream-bitrate');
                if (bitrateEl) {
                    if (relayData.bitrate === 'passthrough') {
                        bitrateEl.textContent = 'Passthrough';
                    } else if (relayData.bitrate === 'initializing') {
                        bitrateEl.textContent = 'Initializing...';
                    } else {
                        bitrateEl.textContent = relayData.bitrate || '--';
                    }
                }

                // Update measured bitrate
                const measuredBitrateEl = document.getElementById('stream-measured-bitrate');
                if (measuredBitrateEl) {
                    if (relayData.measured_bitrate !== undefined && relayData.measured_bitrate > 0) {
                        measuredBitrateEl.textContent = relayData.measured_bitrate;
                    } else {
                        measuredBitrateEl.textContent = '--';
                    }
                }

                // Update network status
                const networkStatusEl = document.getElementById('stream-network-status');
                if (networkStatusEl) {
                    const status = relayData.network_status || 'unknown';
                    networkStatusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    // Apply appropriate styling based on status
                    networkStatusEl.className = 'stat-value connection-status';
                    if (status === 'stable') {
                        networkStatusEl.style.color = '#5cb85c'; // green
                    } else if (status === 'unstable') {
                        networkStatusEl.style.color = '#f0ad4e'; // orange
                    } else if (status === 'congested') {
                        networkStatusEl.style.color = '#d9534f'; // red
                    } else {
                        networkStatusEl.style.color = '';
                    }
                }

                // Update stream health
                const streamHealthEl = document.getElementById('stream-health');
                if (streamHealthEl) {
                    const health = relayData.stream_health || 'unknown';
                    streamHealthEl.textContent = health.charAt(0).toUpperCase() + health.slice(1);
                    // Apply appropriate styling based on health
                    streamHealthEl.className = 'stat-value connection-status';
                    if (health === 'good' || health === 'passthrough') {
                        streamHealthEl.style.color = '#5cb85c'; // green
                    } else if (health === 'degraded') {
                        streamHealthEl.style.color = '#f0ad4e'; // orange
                    } else if (health === 'initializing') {
                        streamHealthEl.style.color = '#5bc0de'; // blue
                    } else {
                        streamHealthEl.style.color = '';
                    }
                }
            } catch (e) {
                console.error('Error updating stream status:', e);
            }
        }

        function startStreamingStatusRefresh() {
            // Use SSE for real-time streaming status updates
            if (streamingStatusEventSource) {
                streamingStatusEventSource.close();
            }
            streamingStatusEventSource = new EventSource('/relay-status-sse');
            streamingStatusEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.status) {
                        const relayData = JSON.parse(data.status);
                        updateStreamStatusWithRelayInfo(relayData);
                    }
                } catch (e) {
                    console.error('Error parsing relay status:', e);
                }
            };
            streamingStatusEventSource.onerror = function() {
                // SSE has terminated, stop the refresh
                stopStreamingStatusRefresh();
            };
        }

        function stopStreamingStatusRefresh() {
            if (streamingStatusEventSource) {
                streamingStatusEventSource.close();
                streamingStatusEventSource = null;
            }
        }

        // Streaming control
        const streamBtn = document.getElementById('stream-btn');
        const streamStatus = document.getElementById('stream-status');
        streamBtn.addEventListener('click', function () {
            // Remove upload box if present when starting streaming
            if (!streaming) {
                const uploadFrame = document.getElementById('upload-frame');
                if (uploadFrame) uploadFrame.remove();
            }
            streamBtn.disabled = true;
            streamStatus.textContent = streaming ? 'Stopping...' : 'Starting...';
            streamStatus.style.display = '';
            fetch('/stream-control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: streaming ? 'stop' : 'start' })
            })
                .then(r => r.json().then(data => ({ status: r.status, data })))
                .then(result => {
                    if (result.status !== 200 && result.data && result.data.error) {
                        streamStatus.textContent = result.data.error;
                        streamStatus.style.display = '';
                        streamStatus.style.color = '#fff';
                        streamStatus.style.backgroundColor = '#d9534f'; // Bootstrap danger
                        streamStatus.style.padding = '0.5em 1em';
                        streamStatus.style.borderRadius = '6px';
                        streamStatus.style.fontWeight = 'bold';
                        streamBtn.disabled = false;
                        return;
                    }
                    streaming = !streaming;
                    streamBtn.textContent = streaming ? 'Stop Streaming' : 'Start Streaming';
                    streamStatus.textContent = streaming ? 'Streaming is running.' : 'Streaming is stopped.';
                    streamStatus.style.display = '';
                    streamStatus.style.color = '';
                    streamStatus.style.backgroundColor = '';
                    streamStatus.style.padding = '';
                    streamStatus.style.borderRadius = '';
                    streamStatus.style.fontWeight = '';
                    streamBtn.disabled = false;

                    // Show/hide streaming info panel
                    const streamingInfoPanel = document.getElementById('streaming-info-panel');
                    if (streamingInfoPanel) {
                        streamingInfoPanel.style.display = streaming ? 'block' : 'none';
                    }

                    if (streaming) {
                        // Ensure the active recordings panel is visible again
                        const activeFrame = document.getElementById('active-recordings-frame');
                        if (activeFrame) activeFrame.style.display = '';
                        startActiveRecordingsRefresh();
                        startStreamingStatusRefresh();
                    } else {
                        // Stop SSE connections
                        stopStreamingStatusRefresh();
                        // update and show the upload recordings list
                        updateUploadRecordingsList();
                    }
                })
                .catch(() => {
                    streamStatus.textContent = 'Error.';
                    streamBtn.disabled = false;
                });
        });

        // Add this function after the streaming control logic
        function updateUploadRecordingsList() {
            fetch(window.location.pathname)
                .then(resp => resp.text())
                .then(html => {
                    // Create a temporary DOM to parse the new upload-form
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    const newUploadFrame = tempDiv.querySelector('#upload-frame');
                    const oldUploadFrame = document.getElementById('upload-frame');
                    if (newUploadFrame) {
                        if (oldUploadFrame) {
                            oldUploadFrame.replaceWith(newUploadFrame);
                        } else {
                            // Insert after stream-panel
                            const streamPanel = document.getElementById('stream-panel');
                            streamPanel.parentNode.insertBefore(newUploadFrame, streamPanel.nextSibling);
                        }
                    } else if (oldUploadFrame) {
                        oldUploadFrame.remove();
                    }
                    // Re-initialize upload form JS
                    if (newUploadFrame) {
                        // Re-run the upload form JS logic
                        document.dispatchEvent(new Event('DOMContentLoaded'));
                    }
                });
        }
    </script>
    {% endif %}

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const deleteBtn = document.getElementById('delete-btn');
            const moveToUsbBtn = document.getElementById('move-to-usb-btn');
            const uploadForm = document.getElementById('upload-form');
            const uploadBtn = document.getElementById('upload-btn');
            const uploadResult = document.getElementById('upload-result');
            
            // Move to USB Drive functionality
            if (moveToUsbBtn && uploadForm) {
                moveToUsbBtn.onclick = async function () {
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        uploadResult.innerHTML = '<span style="color:red;">No recordings selected.</span>';
                        return;
                    }
                    
                    if (!confirm('Move selected recordings to USB drive?')) return;
                    
                    moveToUsbBtn.disabled = true;
                    let movedCount = 0;
                    let resultList = uploadResult.querySelector('ul');
                    if (!resultList) {
                        resultList = document.createElement('ul');
                        uploadResult.innerHTML = '';
                        uploadResult.appendChild(resultList);
                    }
                    resultList.innerHTML = '';
                    
                    for (let i = 0; i < checkboxes.length; i++) {
                        const filePath = checkboxes[i].value;
                        const li = document.createElement('li');
                        li.textContent = `Moving ${filePath} to USB... (${i + 1}/${checkboxes.length})`;
                        resultList.appendChild(li);
                        
                        try {
                            const resp = await fetch('/move-to-usb', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ file_path: filePath })
                            });
                            const result = await resp.json();
                            
                            if (resp.ok && !result.error) {
                                li.style.color = 'green';
                                li.textContent = `Moved ${filePath} to USB: ${result.destination || 'Success'}`;
                                movedCount++;
                                const checkboxDiv = checkboxes[i].closest('div');
                                if (checkboxDiv) checkboxDiv.remove();
                            } else {
                                li.style.color = 'red';
                                li.textContent = `Error moving ${filePath}: ${result.error || resp.statusText}`;
                            }
                        } catch (e) {
                            li.style.color = 'red';
                            li.textContent = `Error moving ${filePath}: ${e.message}`;
                        }
                    }
                    
                    if (movedCount > 0) {
                        const summary = document.createElement('li');
                        summary.style.color = 'green';
                        summary.textContent = `Successfully moved ${movedCount} file(s) to USB drive.`;
                        resultList.appendChild(summary);
                    }
                    
                    moveToUsbBtn.disabled = false;
                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                        uploadBtn.remove();
                        moveToUsbBtn.remove();
                        deleteBtn.remove();
                    }
                };
            }
            
            // Delete functionality
            if (deleteBtn && uploadForm) {
                deleteBtn.onclick = async function () {
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        uploadResult.innerHTML = '<span style="color:red;">No recordings selected.</span>';
                        return;
                    } if (!confirm('Delete selected recordings?')) return;
                    deleteBtn.disabled = true;
                    let deletedCount = 0;
                    let resultList = uploadResult.querySelector('ul');
                    if (!resultList) {
                        resultList = document.createElement('ul');
                        uploadResult.innerHTML = '';
                        uploadResult.appendChild(resultList);
                    }
                    resultList.innerHTML = '';
                    for (let i = 0; i < checkboxes.length; i++) {
                        const filePath = checkboxes[i].value;
                        const li = document.createElement('li');
                        li.textContent = `Deleting ${filePath}... (${i + 1}/${checkboxes.length})`;
                        resultList.appendChild(li);
                        try {
                            const resp = await fetch('/delete-recording', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ file_path: filePath })
                            });
                            const result = await resp.json();
                            if (resp.ok && !result.error) {
                                li.style.color = 'green';
                                li.textContent = `Deleted ${filePath}`;
                                deletedCount++;
                                const checkboxDiv = checkboxes[i].closest('div');
                                if (checkboxDiv) checkboxDiv.remove();
                            } else {
                                li.style.color = 'red';
                                li.textContent = `Error deleting ${filePath}: ${result.error || resp.statusText}`;
                            }
                        } catch (e) {
                            li.style.color = 'red';
                            li.textContent = `Error deleting ${filePath}: ${e.message}`;
                        }
                    }
                    if (deletedCount > 0) {
                        const summary = document.createElement('li');
                        summary.style.color = 'green';
                        summary.textContent = `Successfully deleted ${deletedCount} file(s).`;
                        resultList.appendChild(summary);
                    }
                    deleteBtn.disabled = false;
                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                        uploadBtn.remove();
                        if (moveToUsbBtn) moveToUsbBtn.remove();
                        deleteBtn.remove();
                    }
                };
            }
        });
    </script>
</body>

</html>