<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>System Stats - RPI Streamer</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    <style>
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            margin: 0;
        }
        
        .collapsible-header:hover {
            opacity: 0.8;
        }
        
        .collapse-icon {
            margin-right: 0.5rem;
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }
        
        .collapsible-content {
            transition: max-height 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        .collapsible-content:not(.collapsed) {
            max-height: none;
            opacity: 1;
        }
          .collapsed + .collapsible-content .collapse-icon {
            transform: rotate(-90deg);
        }
        
        /* System Diagnostics Styles */
        .diagnostics-status {
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #808080;
            animation: pulse 2s infinite;
        }
        
        .status-dot.healthy {
            background-color: #28a745;
        }
        
        .status-dot.warning {
            background-color: #ffc107;
        }
        
        .status-dot.critical {
            background-color: #dc3545;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Service status styling */
        .service-status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .service-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #6c757d;
        }
        
        .service-status-dot.active {
            background-color: #28a745;
            animation: pulse 2s infinite;
        }
        
        .service-status-dot.inactive {
            background-color: #dc3545;
        }
        
        .service-status-dot.warning {
            background-color: #ffc107;
        }
        
        /* Service log viewer styling */
        .service-item {
            position: relative;
        }
        
        .service-controls {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
        }
        
        .service-log-btn, .service-enable-btn, .service-disable-btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            flex: 1;
            min-width: 80px;
        }
        
        .service-enable-btn {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
        }
        
        .service-enable-btn:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }
        
        .service-disable-btn {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #212529;
        }
        
        .service-disable-btn:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }
        
        .service-log-viewer {
            margin-top: 1.5rem;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .log-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
            background-color: #e9ecef;
            border-radius: 8px 8px 0 0;
        }
        
        .log-viewer-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #495057;
        }
        
        .log-viewer-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .log-viewer-controls .btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
        }
        
        .log-content {
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
            padding: 1rem;
            background-color: #1e1e1e;
            color: #d4d4d4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .log-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .log-content::-webkit-scrollbar-track {
            background: #2d2d30;
        }
        
        .log-content::-webkit-scrollbar-thumb {
            background: #464647;
            border-radius: 4px;
        }
        
        .log-content::-webkit-scrollbar-thumb:hover {
            background: #5a5a5c;
        }
        
        .log-viewer-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            border-top: 1px solid #dee2e6;
            background-color: #e9ecef;
            border-radius: 0 0 8px 8px;
        }
        
        .log-status {
            color: #6c757d;
            font-weight: 500;
        }
        
        .log-status.connected {
            color: #28a745;
        }
        
        .log-status.error {
            color: #dc3545;
        }
        
        .log-status.paused {
            color: #ffc107;
        }
        
        .log-info {
            color: #6c757d;
        }
        
        /* Log entry styling */
        .log-entry {
            margin-bottom: 0.1rem;
        }
        
        .log-entry.error {
            color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffd93d;
        }
        
        .log-entry.info {
            color: #74c0fc;
        }
        
        .log-entry.success {
            color: #51cf66;
        }
        
        .log-timestamp {
            color: #868e96;
            margin-right: 0.5rem;
        }
        
        .diagnostics-alerts {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .diagnostics-alerts.critical {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
        
        .alert-section h4 {
            margin: 0 0 0.5rem 0;
            color: #856404;
            font-size: 1em;
        }
        
        .diagnostics-alerts.critical .alert-section h4 {
            color: #721c24;
        }
        
        .alert-section ul {
            margin: 0;
            padding-left: 1.2rem;
        }
        
        .alert-section li {
            margin: 0.25rem 0;
            color: #856404;
        }
        
        .diagnostics-alerts.critical .alert-section li {
            color: #721c24;
        }
        
        .diagnostics-details {
            margin-top: 1rem;
        }
        
        .details-toggle {
            margin: 0 0 1rem 0;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #007bff;
            font-size: 1em;
            transition: color 0.2s;
        }
        
        .details-toggle:hover {
            color: #0056b3;
        }
        
        .details-toggle .collapse-icon {
            transition: transform 0.3s ease;
        }
        
        .details-toggle.expanded .collapse-icon {
            transform: rotate(90deg);
        }
        
        .detailed-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .diagnostics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .diag-category {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .diag-category h5 {
            margin: 0 0 0.75rem 0;
            color: #495057;
            font-size: 1em;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 0.5rem;
        }
        
        .diag-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            font-size: 0.9em;
        }
        
        .diag-label {
            color: #6c757d;
            font-weight: 500;
        }
        
        .diag-value {
            font-family: 'Courier New', monospace;
            color: #495057;
            font-weight: bold;
        }
        
        .diag-value.error {
            color: #dc3545;
        }
        
        .diag-value.warning {
            color: #ffc107;
        }
        
        /* Panel Header Styles */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: nowrap;
        }
        
        .panel-header h2 {
            margin: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .panel-header .btn {
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        /* Responsive Styles */
        @media (max-width: 768px) {
            .panel-header {
                gap: 10px;
            }
            
            .panel-header h2 {
                font-size: 1.3em;
            }
            
            .panel-header .btn {
                font-size: 0.9em !important;
                padding: 8px 14px !important;
            }
        }
        
        @media (max-width: 480px) {
            .panel-header h2 {
                font-size: 1.1em;
            }
            
            .panel-header .btn {
                font-size: 0.85em !important;
                padding: 6px 12px !important;
            }
        }
        
        /* GPS Tracks Panel Styles */
        .track-item {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: box-shadow 0.2s;
        }
        
        .track-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .track-name {
            font-weight: bold;
            color: #495057;
            font-size: 1.1em;
        }
        
        .track-date {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .track-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .track-detail {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .track-actions {
            margin-top: 0.75rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .track-btn {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .track-details {
                grid-template-columns: 1fr;
                gap: 0.25rem;
            }
            
            .track-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.25rem;
            }
        }
    </style>
</head>

<body>
    {% set uploadrecordingsonly = request.args.get('uploadrecordingsonly') == '1' %}
    {% if not uploadrecordingsonly %}
    {% include 'navbar.html' %}
    {% endif %}

    <div class="container">
        {% if not uploadrecordingsonly %}        <!-- System Stats -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="system-stats-content">
                <span class="collapse-icon">▼</span>
                System Statistics
            </h2>
            <div id="system-stats-content" class="collapsible-content">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="cpu">--</span>
                        <div class="stat-label">CPU Usage (%)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="mem">--</span>
                        <div class="stat-label">Memory Usage (%)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="temp">--</span>
                        <div class="stat-label">Temperature</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="fan-rpm">--</span>
                        <div class="stat-label">Fan RPM</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="power">--</span>
                        <div class="stat-label">Power Draw</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Network Connection -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="network-content">
                <span class="collapse-icon">▼</span>
                Network Connection
            </h2>
            <div id="network-content" class="collapsible-content">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="ethernet">--</span>
                        <div class="stat-label">Ethernet</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="wifi">--</span>
                        <div class="stat-label">WiFi</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="4g">--</span>
                        <div class="stat-label">4G Dongle</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="gps">--</span>
                        <div class="stat-label">GPS</div>
                    </div>
                </div>

                <!-- WiFi Details Section -->
                <div id="wifi-details" style="margin-top: 1rem; display: none;">
                    <h3>WiFi Details</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-signal">--</span>
                            <div class="stat-label">Signal Strength</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-tx-bitrate">--</span>
                            <div class="stat-label">TX Bitrate</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="wifi-rx-bitrate">--</span>
                            <div class="stat-label">RX Bitrate</div>
                        </div>
                    </div>
                </div>

                <!-- 4G Dongle Details Section -->
                <div id="4g-details" style="margin-top: 1rem; display: none;">
                    <h3>4G Dongle Details</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="4g-signal">--</span>
                            <div class="stat-label">Signal Strength</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="4g-operator">--</span>
                            <div class="stat-label">Operator</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="4g-network-type">--</span>
                            <div class="stat-label">Network Type</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="4g-ip">--</span>
                            <div class="stat-label">IP Address</div>
                        </div>
                    </div>
                </div>

                <!-- GPS Details Section -->
                <div id="gps-details" style="margin-top: 1rem; display: none;">
                    <h3>GPS Details</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-value" id="gps-fix-status">--</span>
                            <div class="stat-label">Fix Status</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="gps-satellites">--</span>
                            <div class="stat-label">Satellites</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="gps-accuracy">--</span>
                            <div class="stat-label">Accuracy</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="gps-location">--</span>
                            <div class="stat-label">Location</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="gps-altitude">--</span>
                            <div class="stat-label">Altitude</div>
                        </div>
                    </div>
                    
                    <h4>GNSS Constellations</h4>
                    <div class="stats-grid" id="gps-constellations">
                        <div class="stat-item">
                            <span class="stat-value" id="gps-constellation-summary">--</span>
                            <div class="stat-label">Active Systems</div>
                        </div>
                    </div>
                </div>

                <!-- IP Addresses Section -->
                <div id="ip-addresses" style="margin-top: 1rem; display: none;">
                    <h3>IP Addresses</h3>
                    <div id="ip-list" class="ip-list">
                        <!-- IP addresses will be populated here -->
                    </div>
                </div>
            </div>        </div>

        <!-- Service Monitoring -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="service-monitoring-content">
                <span class="collapse-icon">▼</span>
                Service Monitoring
            </h2>
            <div id="service-monitoring-content" class="collapsible-content">
                <div class="stats-grid">
                    <div class="stat-item service-item" data-service="gps-daemon">
                        <span class="stat-value connection-status" id="service-gps-daemon">--</span>
                        <div class="stat-label">GPS Daemon</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="gps-daemon">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="gps-daemon" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="gps-daemon" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="gps-startup">
                        <span class="stat-value connection-status" id="service-gps-startup">--</span>
                        <div class="stat-label">GPS Startup</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="gps-startup">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="gps-startup" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="gps-startup" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="mediamtx">
                        <span class="stat-value connection-status" id="service-mediamtx">--</span>
                        <div class="stat-label">MediaMTX</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="mediamtx">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="mediamtx" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="mediamtx" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="heartbeat-daemon">
                        <span class="stat-value connection-status" id="service-heartbeat-daemon">--</span>
                        <div class="stat-label">Heartbeat Daemon</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="heartbeat-daemon">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="heartbeat-daemon" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="heartbeat-daemon" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="ups-monitor">
                        <span class="stat-value connection-status" id="service-ups-monitor">--</span>
                        <div class="stat-label">UPS Monitor</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="ups-monitor">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="ups-monitor" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="ups-monitor" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="relay-ffmpeg.py">
                        <span class="stat-value connection-status" id="service-relay-ffmpeg.py">--</span>
                        <div class="stat-label">Relay FFmpeg</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="relay-ffmpeg.py">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="relay-ffmpeg.py" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="relay-ffmpeg.py" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                    <div class="stat-item service-item" data-service="relay-ffmpeg-record.py">
                        <span class="stat-value connection-status" id="service-relay-ffmpeg-record.py">--</span>
                        <div class="stat-label">Relay FFmpeg Record</div>
                        <div class="service-controls">
                            <button class="btn btn-sm btn-secondary service-log-btn" data-service="relay-ffmpeg-record.py">📋 View Logs</button>
                            <button class="btn btn-sm btn-success service-enable-btn" data-service="relay-ffmpeg-record.py" style="display: none;">▶️ Start</button>
                            <button class="btn btn-sm btn-warning service-disable-btn" data-service="relay-ffmpeg-record.py" style="display: none;">⏹️ Stop</button>
                        </div>
                    </div>
                </div>
                
                <!-- Service Log Viewer -->
                <div id="service-log-viewer" class="service-log-viewer" style="display: none;">
                    <div class="log-viewer-header">
                        <h3 id="log-viewer-title">Service Logs</h3>
                        <div class="log-viewer-controls">
                            <button id="log-clear-btn" class="btn btn-sm btn-warning">🗑️ Clear</button>
                            <button id="log-pause-btn" class="btn btn-sm btn-info">⏸️ Pause</button>
                            <button id="log-close-btn" class="btn btn-sm btn-danger">✖️ Close</button>
                        </div>
                    </div>
                    <div id="log-content" class="log-content"></div>
                    <div class="log-viewer-footer">
                        <small id="log-status" class="log-status">Connecting...</small>
                        <small class="log-info">Last 50 lines shown | Auto-scroll enabled</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- System Diagnostics -->
        <div class="frame">
            <h2 class="collapsible-header" data-target="diagnostics-content">
                <span class="collapse-icon">▼</span>
                System Diagnostics
            </h2>
            <div id="diagnostics-content" class="collapsible-content">
                <div class="diagnostics-status" id="diagnostics-status">
                    <div class="status-indicator" id="diagnostics-health">
                        <span class="status-dot"></span>
                        <span id="health-text">Checking...</span>
                    </div>
                </div>
                
                <!-- Throttling/Undervoltage Alerts -->
                <div id="diagnostics-alerts" class="diagnostics-alerts" style="display: none;">
                    <div class="alert-section">
                        <h4>Current Issues</h4>
                        <ul id="current-issues"></ul>
                    </div>
                    <div class="alert-section">
                        <h4>Past Issues</h4>
                        <ul id="past-issues"></ul>
                    </div>
                </div>

                <!-- Detailed Diagnostics (collapsible) -->
                <div class="diagnostics-details">
                    <h4 class="details-toggle" id="details-toggle">
                        <span class="collapse-icon">▶</span>
                        Detailed Information
                    </h4>
                    <div id="detailed-diagnostics" class="detailed-content" style="display: none;">
                        <div class="diagnostics-grid">
                            <!-- Temperature & PMIC -->
                            <div class="diag-category">
                                <h5>Temperature & PMIC</h5>
                                <div class="diag-item">
                                    <span class="diag-label">Temperature:</span>
                                    <span class="diag-value" id="diag-temperature">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Fan RPM:</span>
                                    <span class="diag-value" id="diag-fan-rpm">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">PMIC Core Voltage:</span>
                                    <span class="diag-value" id="diag-pmic-vdd-core-v">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">PMIC Core Current:</span>
                                    <span class="diag-value" id="diag-pmic-vdd-core-a">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">PMIC External 5V:</span>
                                    <span class="diag-value" id="diag-pmic-ext5v-v">--</span>
                                </div>
                            </div>

                            <!-- UPS Status -->
                            <div class="diag-category" id="ups-section">
                                <h5>UPS Status</h5>
                                <div class="diag-item">
                                    <span class="diag-label">UPS Voltage:</span>
                                    <span class="diag-value" id="diag-ups-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Capacity:</span>
                                    <span class="diag-value" id="diag-ups-capacity">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Status:</span>
                                    <span class="diag-value" id="diag-ups-battery-status">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Power Source:</span>
                                    <span class="diag-value" id="diag-ups-ac-power">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Monitor Log:</span>
                                    <span class="diag-value">
                                        <a href="/ups-monitor-log" target="_blank" style="color: #007bff; text-decoration: none;">View Log</a>
                                    </span>
                                </div>
                            </div>

                            <!-- Memory Split -->
                            <div class="diag-category">
                                <h5>Memory Split</h5>
                                <div class="diag-item">
                                    <span class="diag-label">ARM Memory:</span>
                                    <span class="diag-value" id="diag-mem-arm">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">GPU Memory:</span>
                                    <span class="diag-value" id="diag-mem-gpu">--</span>
                                </div>
                            </div>

                            <!-- Codecs -->
                            <div class="diag-category">
                                <h5>Hardware Codecs</h5>
                                <div class="diag-item">
                                    <span class="diag-label">H264:</span>
                                    <span class="diag-value" id="diag-codec-h264">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">MPG2:</span>
                                    <span class="diag-value" id="diag-codec-mpg2">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">WVC1:</span>
                                    <span class="diag-value" id="diag-codec-wvc1">--</span>
                                </div>
                            </div>

                            <!-- INA219 Power Monitoring -->
                            <div class="diag-category" id="ina219-section">
                                <h5>Power Monitoring (INA219)</h5>
                                <div class="diag-item">
                                    <span class="diag-label">Bus Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-bus-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Shunt Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-shunt-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Current:</span>
                                    <span class="diag-value" id="diag-ina219-current">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Power:</span>
                                    <span class="diag-value" id="diag-ina219-power">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">PSU Voltage:</span>
                                    <span class="diag-value" id="diag-ina219-psu-voltage">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Power Source:</span>
                                    <span class="diag-value" id="diag-ina219-power-source">--</span>
                                </div>
                                <div class="diag-item">
                                    <span class="diag-label">Battery Level:</span>
                                    <span class="diag-value" id="diag-ina219-battery-percent">--</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GPS Tracking -->
        <div class="frame" id="gps-panel">
            <div class="panel-header">
                <h2>Flight Control</h2>
                <a href="/flight-settings" class="btn btn-secondary" style="font-size: 1em; padding: 10px 18px;">⚙️ Settings</a>
            </div>
            
            <!-- Flight Settings Info -->
            <div class="flight-info" style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 1rem; font-size: 14px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>
                        <strong>Username:</strong> {{ settings.username or 'Not configured' }}
                    </div>
                    <div>
                        <strong>Vehicle:</strong> {{ settings.vehicle or 'Not set' }}
                    </div>
                    <div>
                        <strong>Start Mode:</strong> 
                        {% if settings.gps_start_mode == 'manual' %}Manual
                        {% elif settings.gps_start_mode == 'boot' %}Auto (Boot)
                        {% elif settings.gps_start_mode == 'motion' %}Auto (Motion)
                        {% else %}{{ settings.gps_start_mode }}
                        {% endif %}
                    </div>
                    <div>
                        <strong>Stream Link:</strong> {{ 'Enabled' if settings.gps_stream_link else 'Disabled' }}
                    </div>
                </div>
                {% if not settings.username %}
                <div style="margin-top: 8px; color: #dc3545; font-size: 13px;">
                    🔧 Configure username in <a href="/flight-settings" style="color: #0d6efd;">Flight Settings</a> to enable GPS tracking
                </div>
                {% endif %}
            </div>
            
            <div style="text-align: center; margin-bottom: 1.5rem;">
                <button id="gps-btn" class="btn btn-primary" {% if not settings.username %}disabled title="Configure username in Flight Settings first"{% endif %}>
                    {{ 'Stop GPS Tracking' if gps_tracking else 'Start GPS Tracking' }}
                </button>
            </div>
            <div id="gps-status" class="status-info" style="text-align: center;">
                {% if gps_tracking %}
                    <p><strong>Status:</strong> <span class="status-active">Active</span></p>
                    
                    <!-- GPS status message with color coding -->
                    {% if gps_status.hardware_status == 'active' %}
                        <p><em style="color: #28a745;">{{ gps_status.status_message }}</em></p>
                    {% elif gps_status.hardware_status == 'connected' %}
                        <p><em style="color: #ffc107;">{{ gps_status.status_message }}</em></p>
                    {% elif gps_status.hardware_status == 'disconnected' %}
                        <p><em style="color: #dc3545;">{{ gps_status.status_message }}</em></p>
                    {% elif gps_status.hardware_status == 'error' %}
                        <p><em style="color: #dc3545;">{{ gps_status.status_message }}</em></p>
                    {% elif gps_status.hardware_status == 'waiting' %}
                        <p><em style="color: #6c757d;">{{ gps_status.status_message }}</em></p>
                    {% else %}
                        <p><em style="color: #6c757d;">{{ gps_status.status_message }}</em></p>
                    {% endif %}
                    
                    {% if settings.gps_stream_link %}
                    <p><em>Video streaming will automatically control with GPS tracking</em></p>
                    {% endif %}
                    
                    {% if gps_status.last_update %}
                    <p style="font-size: 12px; color: #6c757d; margin-top: 8px;">
                        Last update: {{ gps_status.last_update[:19].replace('T', ' ') }}
                    </p>
                    {% endif %}
                {% else %}
                    <p><strong>Status:</strong> <span class="status-inactive">Inactive</span></p>
                    {% if settings.gps_start_mode == 'manual' %}
                        <p><em>Click "Start GPS Tracking" to begin location tracking</em></p>
                    {% elif settings.gps_start_mode == 'boot' %}
                        <p><em>GPS tracking will auto-start on system boot</em></p>
                    {% elif settings.gps_start_mode == 'motion' %}
                        <p><em>GPS tracking will auto-start when aircraft moves</em></p>
                    {% endif %}
                {% endif %}
            </div>
        </div>

        <!-- GPS Tracks Panel -->
        <div class="frame" id="gps-tracks-panel">
            <div class="panel-header">
                <h2>📊 Flight Tracks</h2>
                <button id="refresh-tracks-btn" class="btn btn-secondary" style="font-size: 1em; padding: 10px 18px; width:auto">🔄 Refresh</button>
            </div>
            
            <div id="tracks-info" style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 1rem; font-size: 14px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Total Tracks:</strong> <span id="total-tracks-count">--</span>
                    </div>
                    <div>
                        <strong>Storage:</strong> <span id="tracks-storage-location">--</span>
                    </div>
                </div>
            </div>
            
            <div id="tracks-container">
                <div id="tracks-loading" style="text-align: center; padding: 2rem; color: #6c757d;">
                    <div>🔄 Loading tracks...</div>
                </div>
                
                <div id="tracks-list" style="display: none;">
                    <!-- Tracks will be populated here -->
                </div>
                
                <div id="tracks-empty" style="display: none; text-align: center; padding: 2rem; color: #6c757d;">
                    <div>📍 No flight tracks found</div>
                    <div style="font-size: 0.9em; margin-top: 0.5rem;">
                        Start GPS tracking to create your first flight track
                    </div>
                </div>
                
                <div id="tracks-error" style="display: none; text-align: center; padding: 2rem; color: #dc3545;">
                    <div>❌ Error loading tracks</div>
                    <div id="tracks-error-message" style="font-size: 0.9em; margin-top: 0.5rem;"></div>
                </div>
            </div>
        </div>

        <!-- Stream Control -->
        <div class="frame" id="stream-panel">
            <div class="panel-header">
                <h2>Stream Control</h2>
                <a href="/stream-settings" class="btn btn-secondary" style="font-size: 1em; padding: 10px 18px;">⚙️ Settings</a>
            </div>
            <div style="text-align: center; margin-bottom: 1.5rem;">
                <button id="stream-btn" class="btn btn-primary">
                    {{ 'Stop Streaming' if streaming else 'Start Streaming' }}
                </button>
            </div>
            <div id="stream-status" class="status-message" style="display: none;"></div>

            <!-- Streaming Information Panel -->
            <div id="streaming-info-panel" style="margin-top: 1rem; display: {{ 'block' if streaming else 'none' }};">
                <h3>Streaming Information</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="stream-bitrate">--</span>
                        <div class="stat-label">Bitrate (kbps)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stream-measured-bitrate">--</span>
                        <div class="stat-label">Measured Bitrate (kbps)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="stream-network-status">--</span>
                        <div class="stat-label">Network Status</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value connection-status" id="stream-health">--</span>
                        <div class="stat-label">Stream Health</div>
                    </div>
                </div>
            </div>

            <!-- Active Recordings Panel -->
            <div id="active-recordings-frame" style="margin-top: 2rem; display: none;">
                <h2>Active Recordings</h2>
                <div class="file-list" id="active-recordings-list"></div>
            </div>
        </div>
        {% endif %}

        <!-- Upload Recordings -->
        {% if (recording_files and not streaming) or uploadrecordingsonly %}
        <div class="frame" id="upload-frame">
            <h2>Upload Recordings</h2>
            <form id="upload-form">
                <div class="file-list">
                    {% if recording_files %}
                    {% for file in recording_files if not file.active %}
                    <div class="file-item">
                        <input type="checkbox" class="upload-checkbox file-checkbox" id="recfile{{ loop.index }}"
                            name="recording_files" value="{{ file.path }}" checked>
                        <label for="recfile{{ loop.index }}" class="file-info" data-info='{{ {'timestamp':
                            file.timestamp, 'duration' : file.duration}|tojson|safe }}'>
                            <strong>Timestamp:</strong> {{ file.timestamp | datetimeformat }}<br>
                            <strong>Duration:</strong> {{ file.duration | durationformat }}<br>
                            <strong>Size:</strong> {{ file.size | filesizeformat }}<br>
                            <strong>Bitrate:</strong> {% if file.duration and file.duration > 0 %}{{ ((file.size * 8) // file.duration // 1000) }} kbps{% else %}--{% endif %}<br>
                            <strong>Location:</strong> {{ file.location }}
                        </label>
                    </div>
                    {% endfor %}
                    {% else %}
                    <div class="file-item">
                        <p>No recordings available for upload.</p>
                    </div>
                    {% endif %}
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap;">
                    <button type="submit" id="upload-btn" class="btn btn-success">Upload to Server</button>
                    <button type="button" id="move-to-usb-btn" class="btn btn-primary">Move to USB Drive</button>
                    <button type="button" id="delete-btn" class="btn btn-danger">Delete Selected</button>
                </div>
                <div id="upload-result" style="margin-top: 1.5rem;"></div>
            </form>
        </div>
        {% endif %}
    </div>

    <script>
        // Ensure streaming variable is available before any script uses it
        // eslint-disable-next-line no-unused-vars, no-undef
        var streaming = {{ streaming | tojson | safe }};
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const uploadForm = document.getElementById('upload-form');
            const uploadBtn = document.getElementById('upload-btn');
            const uploadResult = document.getElementById('upload-result');
            if (uploadForm) {
                let resultList = document.createElement('ul');
                resultList.style.textAlign = 'left';
                uploadResult.innerHTML = '';
                uploadResult.appendChild(resultList);
                uploadForm.onsubmit = async function (e) {
                    e.preventDefault();
                    resultList.innerHTML = '';
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        resultList.innerHTML = '<li style="color:red;">No recordings selected.</li>';
                        return;
                    }

                    // Filter out files that are already uploading
                    const filesToUpload = [];
                    const skippedFiles = [];

                    for (const checkbox of checkboxes) {
                        const filePath = checkbox.value;
                        const fileItemDiv = checkbox.closest('.file-item');
                        const existingContainer = fileItemDiv.querySelector('.upload-progress-container');

                        if (existingContainer) {
                            skippedFiles.push(filePath.split(/[/\\]/).pop() || filePath);
                        } else {
                            filesToUpload.push(checkbox);
                        }
                    }

                    if (skippedFiles.length > 0) {
                        const li = document.createElement('li');
                        li.style.color = 'orange';
                        li.textContent = `Skipped ${skippedFiles.length} file(s) already uploading: ${skippedFiles.join(', ')}`;
                        resultList.appendChild(li);
                    }

                    if (filesToUpload.length === 0) {
                        return;
                    }

                    let successCount = 0;
                    const activeUploads = [];
                    for (let i = 0; i < filesToUpload.length; i++) {
                        const checkbox = filesToUpload[i];
                        const filePath = checkbox.value;
                        const fileName = filePath.split(/[/\\]/).pop() || filePath;
                        // Find the file-item div for this checkbox
                        const fileItemDiv = checkbox.closest('.file-item');

                        // Create upload progress container within the file-item
                        const uploadContainer = document.createElement('div');
                        uploadContainer.className = 'upload-progress-container';
                        uploadContainer.style.marginTop = '0.5rem';
                        uploadContainer.style.padding = '0.5rem';
                        uploadContainer.style.backgroundColor = '#f8f9fa';
                        uploadContainer.style.border = '1px solid #dee2e6';
                        uploadContainer.style.borderRadius = '4px';
                        const statusText = document.createElement('div');
                        statusText.textContent = `Uploading ${fileName}... (${i + 1}/${filesToUpload.length})`;
                        statusText.style.marginBottom = '0.5rem';
                        uploadContainer.appendChild(statusText);

                        const progressContainer = document.createElement('div');
                        progressContainer.style.display = 'flex';
                        progressContainer.style.alignItems = 'center';
                        progressContainer.style.gap = '0.5rem';

                        const progress = document.createElement('progress');
                        progress.value = 0;
                        progress.max = 100;
                        progress.style.width = '200px';
                        progress.style.height = '20px';
                        progressContainer.appendChild(progress);

                        const cancelBtn = document.createElement('button');
                        cancelBtn.textContent = 'Cancel';
                        cancelBtn.type = 'button';
                        cancelBtn.className = 'btn btn-sm btn-danger';
                        cancelBtn.style.padding = '0.25rem 0.5rem';
                        cancelBtn.style.fontSize = '0.875rem';
                        progressContainer.appendChild(cancelBtn);

                        uploadContainer.appendChild(progressContainer);
                        fileItemDiv.appendChild(uploadContainer);

                        // Start the upload
                        const formData = new FormData();
                        formData.append('file_path', filePath);

                        try {
                            const response = await fetch('/upload-recording', {
                                method: 'POST',
                                body: formData
                            });

                            const result = await response.json();
                            if (result.error) {
                                statusText.style.color = 'red';
                                statusText.textContent = `Error uploading ${fileName}: ${result.error}`;
                                uploadContainer.remove();
                                continue;
                            }

                            const uploadId = result.upload_id;
                            let cancelled = false;
                            // Set up cancel button
                            cancelBtn.onclick = async function () {
                                cancelled = true;
                                try {
                                    await fetch(`/cancel-upload/${uploadId}`, { method: 'POST' });
                                    statusText.style.color = 'red';
                                    statusText.textContent = `Upload cancelled: ${fileName}`;
                                    uploadContainer.remove();
                                    // Remove from active uploads immediately
                                    const index = activeUploads.indexOf(uploadId);
                                    if (index > -1) activeUploads.splice(index, 1);
                                } catch (e) {
                                    console.error('Error cancelling upload:', e);
                                }
                            };

                            // Use SSE for real-time progress monitoring
                            let eventSource = null;

                            const startProgressMonitoring = () => {
                                if (cancelled) return;

                                eventSource = new EventSource(`/upload-progress-stream/${uploadId}`);

                                eventSource.onmessage = function (event) {
                                    if (cancelled) {
                                        eventSource.close();
                                        return;
                                    }

                                    try {
                                        const progressData = JSON.parse(event.data);

                                        if (progressData.type === 'connected') {
                                            console.log(`SSE connected for upload ${uploadId}`);
                                            return;
                                        }

                                        if (progressData.type === 'closed') {
                                            eventSource.close();
                                            return;
                                        }
                                        if (progressData.type === 'progress') {
                                            if (progressData.error) {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Error uploading ${fileName}: ${progressData.error}`;
                                                uploadContainer.remove();
                                                eventSource.close();
                                                return;
                                            }

                                            // Update progress bar
                                            progress.value = progressData.progress || 0;

                                            if (progressData.status === 'completed') {
                                                const uploadResult = progressData.result;
                                                if (uploadResult && uploadResult.error) {
                                                    statusText.style.color = 'red';
                                                    statusText.textContent = `Error uploading ${fileName}: ${uploadResult.error}`;
                                                } else {
                                                    statusText.style.color = 'green';
                                                    let replacedMsg = '';
                                                    if (uploadResult && typeof uploadResult.files_replaced !== 'undefined') {
                                                        replacedMsg = ` (${uploadResult.files_replaced} file${uploadResult.files_replaced == 1 ? '' : 's'} replaced on server)`;
                                                    }
                                                    statusText.textContent = `Uploaded ${fileName}: Success.` + replacedMsg;
                                                    successCount++;
                                                    // Remove the checkbox since upload succeeded
                                                    const checkboxDiv = checkbox.closest('div');
                                                    if (checkboxDiv) checkboxDiv.remove();
                                                }
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);

                                                // Check if all uploads are done
                                                if (activeUploads.length === 0) {
                                                    const summary = document.createElement('li');
                                                    summary.style.color = 'green';
                                                    summary.textContent = `Successfully uploaded ${successCount} file(s).`;
                                                    resultList.appendChild(summary);

                                                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                                                        uploadBtn.remove();
                                                        const moveToUsbBtn = document.getElementById('move-to-usb-btn');
                                                        if (moveToUsbBtn) moveToUsbBtn.remove();
                                                    }
                                                }
                                            } else if (progressData.status === 'error') {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Error uploading ${fileName}: ${progressData.error}`;
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);
                                            } else if (progressData.status === 'cancelled') {
                                                statusText.style.color = 'red';
                                                statusText.textContent = `Upload cancelled: ${fileName}`;
                                                uploadContainer.remove();
                                                eventSource.close();

                                                // Remove from active uploads
                                                const index = activeUploads.indexOf(uploadId);
                                                if (index > -1) activeUploads.splice(index, 1);
                                            }
                                            // For 'uploading' status, just continue receiving updates
                                        }
                                    } catch (e) {
                                        console.error('Error parsing SSE data:', e);
                                    }
                                };
                                eventSource.onerror = function (event) {
                                    console.error('SSE error:', event);
                                    if (!cancelled) {
                                        statusText.style.color = 'red';
                                        statusText.textContent = `Error uploading ${fileName}: Connection lost`;
                                        uploadContainer.remove();
                                        // Remove from active uploads
                                        const index = activeUploads.indexOf(uploadId);
                                        if (index > -1) activeUploads.splice(index, 1);
                                    }
                                    eventSource.close();
                                };
                            };

                            // Add to active uploads and start SSE monitoring
                            activeUploads.push(uploadId);
                            startProgressMonitoring();
                        } catch (e) {
                            statusText.style.color = 'red';
                            statusText.textContent = `Error uploading ${fileName}: ${e.message}`;
                            uploadContainer.remove();
                        }
                    }
                };
            }

            async function getUploadServerUrl() {
                try {
                    const resp = await fetch('/settings');
                    const data = await resp.json();
                    return data.upload_url || '';
                } catch (e) {
                    return '';
                }
            } async function fetchOverlappingInfo(uploadUrl, file, duration) {
                if (!uploadUrl) return null;
                // Handle both Windows and Unix path separators
                const filename = file.split(/[/\\]/).pop();
                let url = new URL(uploadUrl);
                url.searchParams.set('command', 'getrecordingsinfo');
                url.searchParams.set('videofilename', filename);
                url.searchParams.set('duration', duration);
                try {
                    const response = await fetch(url, { method: 'GET' });
                    if (!response.ok) throw new Error('Network response was not ok. URL: ' + url.toString());
                    return await response.json();
                } catch (e) {
                    return { error: e.message + ' (URL: ' + url.toString() + ')' };
                }
            }

            (async function () {
                const uploadUrl = await getUploadServerUrl();
                const checkboxes = document.querySelectorAll('.upload-checkbox');
                for (const checkbox of checkboxes) {
                    const file = checkbox.value;
                    const label = document.querySelector(`label[for="${checkbox.id}"]`);
                    if (!file || !label) continue;
                    const loadingDiv = document.createElement('div');
                    loadingDiv.style.fontSize = '0.9em';
                    loadingDiv.style.color = '#888';
                    loadingDiv.textContent = 'Checking server for overlapping files...';
                    label.appendChild(loadingDiv);
                    loadingDiv.remove();
                    let localInfo = null;
                    try {
                        localInfo = JSON.parse(label.getAttribute('data-info'));
                    } catch (e) { }
                    const info = await fetchOverlappingInfo(uploadUrl, file, localInfo ? localInfo.duration : 0);
                    if (info && info.overlapping_files && info.overlapping_files.length > 0 && localInfo) {
                        const barWidth = 220;
                        const barHeight = 18;
                        const barColor = "#eee";
                        const borderColor = "#bbb";
                        const overlapColor = "#d33";
                        const localStart = Number(localInfo.timestamp);
                        const localDuration = Number(localInfo.duration);
                        const localEnd = localStart + localDuration;
                        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        svg.setAttribute("width", barWidth);
                        svg.setAttribute("height", barHeight);
                        svg.style.display = "block";
                        svg.style.margin = "8px 0";
                        const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bg.setAttribute("x", 0);
                        bg.setAttribute("y", 2);
                        bg.setAttribute("width", barWidth);
                        bg.setAttribute("height", barHeight - 4);
                        bg.setAttribute("fill", barColor);
                        bg.setAttribute("stroke", borderColor);
                        bg.setAttribute("stroke-width", 1);
                        svg.appendChild(bg);
                        info.overlapping_files.forEach(f => {
                            const overlapStart = Math.max(Number(f.timestamp), localStart);
                            const overlapEnd = Math.min(Number(f.timestamp) + Number(f.duration), localEnd);
                            if (overlapEnd > overlapStart) {
                                const x = ((overlapStart - localStart) / localDuration) * barWidth;
                                const w = ((overlapEnd - overlapStart) / localDuration) * barWidth;
                                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                rect.setAttribute("x", x);
                                rect.setAttribute("y", 2);
                                rect.setAttribute("width", w);
                                rect.setAttribute("height", barHeight - 4);
                                rect.setAttribute("fill", overlapColor);
                                rect.setAttribute("opacity", 0.8);
                                svg.appendChild(rect);
                            }
                        });
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#b00';
                        div.innerHTML = 'Overlapping server files:';
                        div.appendChild(svg);
                        const overlaps = info.overlapping_files.map(f =>
                            `Server file: ${f.timestamp} (${f.duration}s, ${f.size_mb} MB)`
                        ).join('<br>');
                        const textDiv = document.createElement('div');
                        textDiv.innerHTML = overlaps;
                        div.appendChild(textDiv);
                        label.appendChild(div);
                    } else if (info && info.error) {
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#b00';
                        div.textContent = 'Error: ' + info.error;
                        label.appendChild(div);
                    } else {
                        const div = document.createElement('div');
                        div.style.fontSize = '0.9em';
                        div.style.color = '#080';
                        div.textContent = 'No overlapping files on server.';
                        label.appendChild(div);
                    }
                }
            })();
        });
    </script>    {% if not uploadrecordingsonly %}
    <script>
        // Collapsible panels functionality
        function initializeCollapsiblePanels() {
            const headers = document.querySelectorAll('.collapsible-header');
            
            headers.forEach(header => {
                const targetId = header.getAttribute('data-target');
                const content = document.getElementById(targetId);
                const icon = header.querySelector('.collapse-icon');
                
                if (!content) return;
                
                // Get saved state from localStorage (default to collapsed)
                const savedState = localStorage.getItem(`panel-${targetId}`);
                const isCollapsed = savedState === null ? true : savedState === 'collapsed';
                
                // Apply initial state
                if (isCollapsed) {
                    content.classList.add('collapsed');
                    icon.style.transform = 'rotate(-90deg)';
                } else {
                    content.classList.remove('collapsed');
                    icon.style.transform = 'rotate(0deg)';
                }
                
                // Add click handler
                header.addEventListener('click', function() {
                    const isCurrentlyCollapsed = content.classList.contains('collapsed');
                    
                    if (isCurrentlyCollapsed) {
                        content.classList.remove('collapsed');
                        icon.style.transform = 'rotate(0deg)';
                        localStorage.setItem(`panel-${targetId}`, 'expanded');
                        
                        // If this is the service monitoring panel and we have stored data, update the UI
                        if (targetId === 'service-monitoring-content' && lastServiceData) {
                            updateServiceStatusUI(lastServiceData);
                        }
                    } else {
                        content.classList.add('collapsed');
                        icon.style.transform = 'rotate(-90deg)';
                        localStorage.setItem(`panel-${targetId}`, 'collapsed');
                    }
                });
            });
        }
          // Initialize collapsible panels when DOM is ready
        // Collapsible panels is now initialized via combined DOMContentLoaded handler
        
        // System Diagnostics functionality  
        let diagnosticsPollingInterval = null;
        
        function initializeDiagnostics() {
            // Handle detailed diagnostics toggle
            const detailsToggle = document.getElementById('details-toggle');
            const detailedDiagnostics = document.getElementById('detailed-diagnostics');
            
            if (detailsToggle && detailedDiagnostics) {
                detailsToggle.addEventListener('click', function() {
                    const isExpanded = detailedDiagnostics.style.display !== 'none';
                    
                    if (isExpanded) {
                        detailedDiagnostics.style.display = 'none';
                        detailsToggle.classList.remove('expanded');
                    } else {
                        detailedDiagnostics.style.display = 'block';
                        detailsToggle.classList.add('expanded');
                    }
                });
            }
            
            // Start polling for diagnostics
            startDiagnosticsPolling();
        }
        
        function startDiagnosticsPolling() {
            if (diagnosticsPollingInterval) {
                clearInterval(diagnosticsPollingInterval);
            }
            
            // Start polling every 5 seconds
            diagnosticsPollingInterval = setInterval(fetchDiagnostics, 5000);
            // Fetch immediately on start
            fetchDiagnostics();
        }
        
        function fetchDiagnostics() {
            // Only fetch if diagnostics panel is visible
            const diagnosticsContent = document.getElementById('diagnostics-content');
            if (diagnosticsContent && diagnosticsContent.classList.contains('collapsed')) {
                return; // Skip polling if panel is collapsed
            }
            
            fetch('/diagnostics')
                .then(response => response.json())
                .then(data => {
                    updateDiagnosticsDisplay(data);
                })
                .catch(error => {
                    console.error('Error fetching diagnostics:', error);
                    // Don't update UI on error, keep last known values
                });
        }
        
        function stopDiagnosticsPolling() {
            if (diagnosticsPollingInterval) {
                clearInterval(diagnosticsPollingInterval);
                diagnosticsPollingInterval = null;
            }
        }
        
        function updateDiagnosticsDisplay(data) {
            // Only update if diagnostics panel is visible
            const diagnosticsContent = document.getElementById('diagnostics-content');
            if (diagnosticsContent && diagnosticsContent.classList.contains('collapsed')) {
                return; // Skip update if panel is collapsed
            }
            
            // Update health status
            const healthText = document.getElementById('health-text');
            const statusDot = document.querySelector('.status-dot');
            const alertsDiv = document.getElementById('diagnostics-alerts');
            const currentIssuesList = document.getElementById('current-issues');
            const pastIssuesList = document.getElementById('past-issues');
            
            if (data.error) {
                if (healthText) healthText.textContent = `Error: ${data.error}`;
                if (statusDot) {
                    statusDot.className = 'status-dot critical';
                }
                return;
            }
            
            // Parse throttled status
            const throttledInfo = data.throttled_parsed || {};
            const hasIssues = throttledInfo.has_issues || false;
            const currentIssues = throttledInfo.current_issues || [];
            const pastIssues = throttledInfo.past_issues || [];
            
            // Update health indicator
            if (healthText && statusDot) {
                if (currentIssues.length > 0) {
                    healthText.textContent = 'Critical Issues Detected';
                    statusDot.className = 'status-dot critical';
                } else if (pastIssues.length > 0) {
                    healthText.textContent = 'Past Issues Detected';
                    statusDot.className = 'status-dot warning';
                } else {
                    healthText.textContent = 'System Healthy';
                    statusDot.className = 'status-dot healthy';
                }
            }
            
            // Update alerts section
            if (alertsDiv && currentIssuesList && pastIssuesList) {
                if (currentIssues.length > 0 || pastIssues.length > 0) {
                    alertsDiv.style.display = 'block';
                    alertsDiv.className = currentIssues.length > 0 ? 'diagnostics-alerts critical' : 'diagnostics-alerts';
                    
                    // Update current issues
                    currentIssuesList.innerHTML = '';
                    if (currentIssues.length > 0) {
                        currentIssues.forEach(issue => {
                            const li = document.createElement('li');
                            li.textContent = issue;
                            currentIssuesList.appendChild(li);
                        });
                    } else {
                        const li = document.createElement('li');
                        li.textContent = 'None';
                        li.style.fontStyle = 'italic';
                        currentIssuesList.appendChild(li);
                    }
                    
                    // Update past issues
                    pastIssuesList.innerHTML = '';
                    if (pastIssues.length > 0) {
                        pastIssues.forEach(issue => {
                            const li = document.createElement('li');
                            li.textContent = issue;
                            pastIssuesList.appendChild(li);
                        });
                    } else {
                        const li = document.createElement('li');
                        li.textContent = 'None';
                        li.style.fontStyle = 'italic';
                        pastIssuesList.appendChild(li);
                    }
                } else {
                    alertsDiv.style.display = 'none';
                }
            }
            
            // Update detailed diagnostics
            updateDetailedDiagnostics(data);
        }
        
        function updateDetailedDiagnostics(data) {
            // Temperature & PMIC
            updateDiagValue('diag-temperature', data.temperature);
            updateDiagValue('diag-fan-rpm', data.fan_rpm);
            updateDiagValue('diag-pmic-vdd-core-v', data.pmic_vdd_core_v);
            updateDiagValue('diag-pmic-vdd-core-a', data.pmic_vdd_core_a);
            updateDiagValue('diag-pmic-ext5v-v', data.pmic_ext5v_v);
            
            // UPS Status - Show/Hide section based on availability
            const upsSection = document.getElementById('ups-section');
            const upsAvailable = data.ups_battery_status && data.ups_battery_status !== 'UPS Not Available';
            if (upsSection) {
                upsSection.style.display = upsAvailable ? 'block' : 'none';
            }
            if (upsAvailable) {
                updateDiagValue('diag-ups-voltage', data.ups_voltage ? data.ups_voltage.toFixed(2) + 'V' : null);
                updateDiagValue('diag-ups-capacity', data.ups_capacity ? data.ups_capacity.toFixed(1) + '%' : null);
                updateDiagValue('diag-ups-battery-status', data.ups_battery_status);
                updateDiagValue('diag-ups-ac-power', data.ups_ac_power !== null ? (data.ups_ac_power ? 'Plugged In' : 'Unplugged') : null);
            }
            
            // Memory Split
            updateDiagValue('diag-mem-arm', data.mem_arm);
            updateDiagValue('diag-mem-gpu', data.mem_gpu);
            
            // Codecs
            updateDiagValue('diag-codec-h264', data.codec_h264);
            updateDiagValue('diag-codec-mpg2', data.codec_mpg2);
            updateDiagValue('diag-codec-wvc1', data.codec_wvc1);
            
            // INA219 Power Monitoring - Show/Hide section based on availability
            const ina219Section = document.getElementById('ina219-section');
            const ina219Available = data.ina219_bus_voltage && 
                                   data.ina219_bus_voltage !== 'INA219 Not Available' && 
                                   !data.ina219_bus_voltage.startsWith('Error:');
            if (ina219Section) {
                ina219Section.style.display = ina219Available ? 'block' : 'none';
            }
            if (ina219Available) {
                updateDiagValue('diag-ina219-bus-voltage', data.ina219_bus_voltage);
                updateDiagValue('diag-ina219-shunt-voltage', data.ina219_shunt_voltage);
                updateDiagValue('diag-ina219-current', data.ina219_current);
                updateDiagValue('diag-ina219-power', data.ina219_power);
                updateDiagValue('diag-ina219-psu-voltage', data.ina219_psu_voltage);
                updateDiagValue('diag-ina219-power-source', data.ina219_power_source);
                updateDiagValue('diag-ina219-battery-percent', data.ina219_battery_percent);
            }
        }
        
        function updateDiagValue(elementId, value) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = value || '--';
                
                // Add styling based on content
                element.className = 'diag-value';
                if (typeof value === 'string') {
                    if (value.includes('Error') || value.includes('not found') || value.includes('Timeout')) {
                        element.classList.add('error');
                    } else if (value.includes('disabled') || value === 'N/A') {
                        element.classList.add('warning');
                    }
                }
            }
        }
        
        // Diagnostics is now initialized via combined DOMContentLoaded handler
        
        const cpu = document.getElementById('cpu');
        const mem = document.getElementById('mem');
        const temp = document.getElementById('temp');
        const fanRpm = document.getElementById('fan-rpm');
        const power = document.getElementById('power');
        const ethernet = document.getElementById('ethernet');
        const wifi = document.getElementById('wifi');
        const dongle4g = document.getElementById('4g');
        const gps = document.getElementById('gps');
        const ipAddressesDiv = document.getElementById('ip-addresses');
        const ipList = document.getElementById('ip-list');
        const wifiDetailsDiv = document.getElementById('wifi-details');
        const wifiSignal = document.getElementById('wifi-signal');
        const wifiTxBitrate = document.getElementById('wifi-tx-bitrate');
        const wifiRxBitrate = document.getElementById('wifi-rx-bitrate');
        const dongle4gDetailsDiv = document.getElementById('4g-details');
        const dongle4gSignal = document.getElementById('4g-signal');
        const dongle4gOperator = document.getElementById('4g-operator');
        const dongle4gNetworkType = document.getElementById('4g-network-type');
        const dongle4gIp = document.getElementById('4g-ip');
        const gpsDetailsDiv = document.getElementById('gps-details');
        const gpsFixStatus = document.getElementById('gps-fix-status');
        const gpsSatellites = document.getElementById('gps-satellites');
        const gpsAccuracy = document.getElementById('gps-accuracy');
        const gpsLocation = document.getElementById('gps-location');
        const gpsAltitude = document.getElementById('gps-altitude');
        const gpsConstellationSummary = document.getElementById('gps-constellation-summary');

        // GNSS Constellation display functions
        function updateGnssConstellations(satelliteData) {
            const constellations = satelliteData.constellations || {};
            
            if (Object.keys(constellations).length === 0) {
                gpsConstellationSummary.textContent = '--';
                return;
            }
            
            // Create summary of active constellations
            const activeConstellations = [];
            for (const [constellation, data] of Object.entries(constellations)) {
                const visible = data.visible || 0;
                const used = data.used || 0;
                
                if (visible > 0) {
                    if (used > 0) {
                        activeConstellations.push(`${constellation} (${used}/${visible})`);
                    } else {
                        activeConstellations.push(`${constellation} (0/${visible})`);
                    }
                }
            }
            
            if (activeConstellations.length === 0) {
                gpsConstellationSummary.textContent = 'No active satellites';
                gpsConstellationSummary.style.color = '#dc3545'; // red
            } else {
                gpsConstellationSummary.textContent = activeConstellations.join(', ');
                gpsConstellationSummary.style.color = '#28a745'; // green
            }
        }
        
        function clearGnssConstellations() {
            gpsConstellationSummary.textContent = '--';
            gpsConstellationSummary.style.color = '';
        }

        // Global polling management
        let statsPollingInterval = null;
        
        function initializeStatsPolling() {
            if (statsPollingInterval) {
                clearInterval(statsPollingInterval);
            }
            
            // Start polling every 5 seconds
            statsPollingInterval = setInterval(fetchStats, 5000);
            // Fetch immediately on start
            fetchStats();
        }
        
        function fetchStats() {
            // Only fetch if system stats panel is visible
            const systemStatsContent = document.getElementById('system-stats-content');
            const networkContent = document.getElementById('network-content');
            
            if (systemStatsContent && systemStatsContent.classList.contains('collapsed') &&
                networkContent && networkContent.classList.contains('collapsed')) {
                return; // Skip polling if both panels are collapsed
            }
            
            fetch('/stats')
                .then(response => response.json())
                .then(data => {
            cpu.textContent = data.cpu;
            mem.textContent = data.mem;
            temp.textContent = data.temp;
            fanRpm.textContent = data.fan_rpm || '--';
            power.textContent = data.power;

            // Handle connection information
            if (data.connection) {
                try {
                    const connection = data.connection; // No need to parse again

                    // Update ethernet and wifi status
                    ethernet.textContent = connection.ethernet || 'Disconnected';
                    wifi.textContent = connection.wifi || 'Disconnected';
                    
                    // Update 4G status with network type if available
                    let dongle4gStatus = connection['4g'] || 'No device';
                    if (connection['4g_dongle'] && connection['4g_dongle'].network_type && 
                        connection['4g'] && connection['4g'] !== 'No device' && !connection['4g'].includes('Error')) {
                        dongle4gStatus = `${connection['4g']} (${connection['4g_dongle'].network_type})`;
                    }
                    dongle4g.textContent = dongle4gStatus;
                    
                    // Update GPS status
                    if (connection.gps) {
                        const gpsStatus = connection.gps;
                        
                        if (gpsStatus.available && gpsStatus.fix_status === "valid") {
                            gps.textContent = "Valid fix";
                            gps.style.color = '#28a745'; // green
                        } else if (gpsStatus.available && gpsStatus.fix_status === "no_fix") {
                            gps.textContent = "No fix";
                            gps.style.color = '#ffc107'; // yellow
                        } else if (gpsStatus.available) {
                            gps.textContent = gpsStatus.fix_status || "Error";
                            gps.style.color = '#dc3545'; // red
                        } else {
                            gps.textContent = "Unavailable";
                            gps.style.color = '#6c757d'; // gray
                        }
                    } else {
                        gps.textContent = "No data";
                        gps.style.color = '#6c757d'; // gray
                    }

                    // Update WiFi details if available
                    // Show panel if WiFi is connected, even if details are temporarily unavailable
                    const isWifiConnected = connection.wifi && connection.wifi !== 'Disconnected' && !connection.wifi.includes('Error');
                    
                    if (isWifiConnected) {
                        wifiDetailsDiv.style.display = 'block';
                        
                        // Get references to the labels so we can change them dynamically
                        const wifiSignalLabel = document.querySelector('#wifi-signal').nextElementSibling;
                        const wifiTxLabel = document.querySelector('#wifi-tx-bitrate').nextElementSibling;
                        const wifiRxLabel = document.querySelector('#wifi-rx-bitrate').nextElementSibling;
                        
                        // Check if we're in hotspot mode
                        if (connection.wifi_details && connection.wifi_details.mode === 'hotspot') {
                            // Hotspot mode - update labels and show appropriate info
                            wifiSignalLabel.textContent = 'Connected Clients';
                            wifiTxLabel.textContent = 'Hotspot SSID';
                            wifiRxLabel.textContent = 'Mode';
                            
                            // Show client count
                            wifiSignal.textContent = `${connection.wifi_details.clients_count} client${connection.wifi_details.clients_count !== 1 ? 's' : ''}`;
                            wifiSignal.style.color = connection.wifi_details.clients_count > 0 ? '#28a745' : '#6c757d'; // green if clients, gray if none
                            
                            // Show hotspot SSID
                            wifiTxBitrate.textContent = connection.wifi_details.ssid || '--';
                            wifiTxBitrate.style.color = '#007bff'; // blue for info
                            
                            // Show hotspot mode
                            wifiRxBitrate.textContent = 'Hotspot Mode';
                            wifiRxBitrate.style.color = '#28a745'; // green for active
                        } else {
                            // Regular WiFi client mode - restore original labels and show signal, bitrates
                            wifiSignalLabel.textContent = 'Signal Strength';
                            wifiTxLabel.textContent = 'TX Bitrate';
                            wifiRxLabel.textContent = 'RX Bitrate';
                            
                            // Signal strength
                            if (connection.wifi_details && connection.wifi_details.signal_percent !== undefined) {
                                const signalPercent = connection.wifi_details.signal_percent;
                                const signalDbm = connection.wifi_details.signal_dbm || '';
                                wifiSignal.textContent = `${signalPercent}%${signalDbm ? ` (${signalDbm} dBm)` : ''}`;
                                
                                // Color code signal strength
                                if (signalPercent >= 70) {
                                    wifiSignal.style.color = '#28a745'; // green
                                } else if (signalPercent >= 40) {
                                    wifiSignal.style.color = '#ffc107'; // yellow
                                } else {
                                    wifiSignal.style.color = '#dc3545'; // red
                                }
                            } else {
                                wifiSignal.textContent = '--';
                                wifiSignal.style.color = '';
                            }
                            
                            // TX Bitrate
                            if (connection.wifi_details && connection.wifi_details.tx_bitrate !== undefined) {
                                wifiTxBitrate.textContent = `${connection.wifi_details.tx_bitrate} Mbps`;
                            } else {
                                wifiTxBitrate.textContent = '--';
                            }
                            
                            // RX Bitrate
                            if (connection.wifi_details && connection.wifi_details.rx_bitrate !== undefined) {
                                wifiRxBitrate.textContent = `${connection.wifi_details.rx_bitrate} Mbps`;
                            } else {
                                wifiRxBitrate.textContent = '--';
                            }
                        }
                    } else {
                        wifiDetailsDiv.style.display = 'none';
                        
                        // Reset labels to default when WiFi is disconnected
                        const wifiSignalLabel = document.querySelector('#wifi-signal').nextElementSibling;
                        const wifiTxLabel = document.querySelector('#wifi-tx-bitrate').nextElementSibling;
                        const wifiRxLabel = document.querySelector('#wifi-rx-bitrate').nextElementSibling;
                        
                        if (wifiSignalLabel) wifiSignalLabel.textContent = 'Signal Strength';
                        if (wifiTxLabel) wifiTxLabel.textContent = 'TX Bitrate';
                        if (wifiRxLabel) wifiRxLabel.textContent = 'RX Bitrate';
                        
                        wifiSignal.textContent = '--';
                        wifiTxBitrate.textContent = '--';
                        wifiRxBitrate.textContent = '--';
                        wifiSignal.style.color = '';
                        wifiTxBitrate.style.color = '';
                        wifiRxBitrate.style.color = '';
                    }

                    // Update 4G dongle details if available
                    const is4gConnected = connection['4g'] && connection['4g'] !== 'No device' && !connection['4g'].includes('Error');
                    
                    if (is4gConnected && connection['4g_dongle']) {
                        dongle4gDetailsDiv.style.display = 'block';
                        
                        const dongleInfo = connection['4g_dongle'];
                        
                        // Signal strength
                        if (dongleInfo.signal_strength) {
                            dongle4gSignal.textContent = dongleInfo.signal_strength;
                            
                            // Color code signal strength for dBm values
                            if (dongleInfo.signal_strength.includes('dBm')) {
                                const dbmMatch = dongleInfo.signal_strength.match(/-?\d+/);
                                if (dbmMatch) {
                                    const dbm = parseInt(dbmMatch[0]);
                                    if (dbm >= -70) {
                                        dongle4gSignal.style.color = '#28a745'; // green
                                    } else if (dbm >= -85) {
                                        dongle4gSignal.style.color = '#ffc107'; // yellow
                                    } else {
                                        dongle4gSignal.style.color = '#dc3545'; // red
                                    }
                                }
                            } else {
                                dongle4gSignal.style.color = '';
                            }
                        } else {
                            dongle4gSignal.textContent = '--';
                            dongle4gSignal.style.color = '';
                        }
                        
                        // Operator
                        dongle4gOperator.textContent = dongleInfo.operator || '--';
                        
                        // Network type
                        dongle4gNetworkType.textContent = dongleInfo.network_type || '--';
                        
                        // IP address
                        dongle4gIp.textContent = dongleInfo.ip_address || '--';
                    } else {
                        dongle4gDetailsDiv.style.display = 'none';
                        dongle4gSignal.textContent = '--';
                        dongle4gOperator.textContent = '--';
                        dongle4gNetworkType.textContent = '--';
                        dongle4gIp.textContent = '--';
                        dongle4gSignal.style.color = '';
                    }

                    // Update GPS details if available
                    const isGpsAvailable = connection.gps && connection.gps.available;
                    const hasGpsFix = isGpsAvailable && connection.gps.fix_status === "valid";
                    
                    if (isGpsAvailable) {
                        gpsDetailsDiv.style.display = 'block';
                        
                        const gpsInfo = connection.gps;
                        
                        // Fix status with color coding
                        const fixStatus = gpsInfo.fix_status || '--';
                        if (fixStatus === 'valid') {
                            gpsFixStatus.textContent = 'Valid fix';
                            gpsFixStatus.style.color = '#28a745'; // green
                        } else if (fixStatus === 'no_fix') {
                            gpsFixStatus.textContent = 'No satellite fix';
                            gpsFixStatus.style.color = '#ffc107'; // yellow
                        } else {
                            gpsFixStatus.textContent = fixStatus;
                            gpsFixStatus.style.color = '#dc3545'; // red
                        }
                        
                        // Satellites count - access from satellites object
                        const satelliteCount = gpsInfo.satellites ? gpsInfo.satellites.total || gpsInfo.satellites.used || 0 : 0;
                        gpsSatellites.textContent = satelliteCount.toString();
                        if (satelliteCount >= 8) {
                            gpsSatellites.style.color = '#28a745'; // green
                        } else if (satelliteCount >= 4) {
                            gpsSatellites.style.color = '#ffc107'; // yellow
                        } else {
                            gpsSatellites.style.color = '#dc3545'; // red
                        }
                        
                        // Accuracy - use direct accuracy value in meters
                        if (gpsInfo.accuracy && typeof gpsInfo.accuracy === 'number') {
                            gpsAccuracy.textContent = `~${gpsInfo.accuracy.toFixed(1)}m`;
                        } else {
                            gpsAccuracy.textContent = '--';
                        }
                        
                        // Altitude - access directly from GPS data
                        if (gpsInfo.altitude !== null && gpsInfo.altitude !== undefined) {
                            gpsAltitude.textContent = `${gpsInfo.altitude.toFixed(1)}m`;
                        } else {
                            gpsAltitude.textContent = '--';
                        }
                        
                        // Enhanced Location display with coordinates only
                        if (gpsInfo.latitude !== null && gpsInfo.latitude !== undefined && 
                            gpsInfo.longitude !== null && gpsInfo.longitude !== undefined) {
                            let locationText = `${gpsInfo.latitude.toFixed(6)}, ${gpsInfo.longitude.toFixed(6)}`;
                            
                            gpsLocation.textContent = locationText;
                            gpsLocation.style.fontSize = '0.8em'; // smaller font for coordinates
                            gpsLocation.style.whiteSpace = 'nowrap'; // Keep coordinates on single line
                        } else {
                            gpsLocation.textContent = '--';
                            gpsLocation.style.whiteSpace = '';
                        }
                        
                        // GNSS Constellations - Use the satellites.constellations path from GPS client
                        const satelliteData = gpsInfo.satellites?.constellations || {};
                        updateGnssConstellations({ constellations: satelliteData });
                    } else {
                        gpsDetailsDiv.style.display = 'none';
                        gpsFixStatus.textContent = '--';
                        gpsSatellites.textContent = '--';
                        gpsAccuracy.textContent = '--';
                        gpsLocation.textContent = '--';
                        gpsAltitude.textContent = '--';
                        gpsFixStatus.style.color = '';
                        gpsSatellites.style.color = '';
                        gpsLocation.style.fontSize = '';
                        gpsLocation.style.whiteSpace = '';
                        
                        // Clear constellation display
                        clearGnssConstellations();
                    }

                    // Update IP addresses
                    if (connection.ip_addresses && connection.ip_addresses.length > 0) {
                        ipAddressesDiv.style.display = 'block';
                        ipList.innerHTML = '';

                        connection.ip_addresses.forEach(function (ipInfo) {
                            const ipItem = document.createElement('div');
                            ipItem.className = 'ip-item';
                            ipItem.innerHTML = '<span class="ip-address">' + ipInfo.ip + '</span> <small>(' + ipInfo.interface + ')</small>';
                            ipList.appendChild(ipItem);
                        });
                    } else {
                        ipAddressesDiv.style.display = 'none';
                    }
                } catch (e) {
                    console.error('Error parsing connection data:', e);
                    ethernet.textContent = 'Error';
                    wifi.textContent = 'Error';
                    dongle4g.textContent = 'Error';
                    gps.textContent = 'Error';
                    wifiDetailsDiv.style.display = 'none';
                    dongle4gDetailsDiv.style.display = 'none';
                    gpsDetailsDiv.style.display = 'none';
                }
            }
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    // Don't update UI on error, keep last known values
                });
        }
    
    // Initialize stats polling when DOM is ready
    // Combine all DOMContentLoaded handlers to prevent duplicate connections
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize collapsible panels first so panel states are ready
        initializeCollapsiblePanels();
        
        initializeStatsPolling();
        initializeDiagnostics();
        startServiceMonitoring();
        initializeLogViewer();
        initializeGPSTracks();
    });
    
    // GPS Tracks functionality
    function initializeGPSTracks() {
        const refreshBtn = document.getElementById('refresh-tracks-btn');
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
                loadGPSTracks();
            });
        }
        
        // Load tracks on page load
        loadGPSTracks();
    }
    
    function loadGPSTracks() {
        const loadingDiv = document.getElementById('tracks-loading');
        const listDiv = document.getElementById('tracks-list');
        const emptyDiv = document.getElementById('tracks-empty');
        const errorDiv = document.getElementById('tracks-error');
        const totalCountSpan = document.getElementById('total-tracks-count');
        const storageLocationSpan = document.getElementById('tracks-storage-location');
        
        // Show loading state
        loadingDiv.style.display = 'block';
        listDiv.style.display = 'none';
        emptyDiv.style.display = 'none';
        errorDiv.style.display = 'none';
        
        fetch('/gps-tracks')
            .then(response => response.json())
            .then(data => {
                loadingDiv.style.display = 'none';
                
                if (data.error) {
                    errorDiv.style.display = 'block';
                    document.getElementById('tracks-error-message').textContent = data.error;
                    totalCountSpan.textContent = '--';
                    storageLocationSpan.textContent = '--';
                    return;
                }
                
                const tracks = data.tracks || [];
                totalCountSpan.textContent = tracks.length;
                
                // Show storage location (extract from tracks_dir)
                if (data.tracks_dir) {
                    const isUSB = data.tracks_dir.includes('/media/') || data.tracks_dir.includes('/mnt/');
                    storageLocationSpan.textContent = isUSB ? '💾 USB Drive' : '💿 Local Storage';
                } else {
                    storageLocationSpan.textContent = '--';
                }
                
                if (tracks.length === 0) {
                    emptyDiv.style.display = 'block';
                } else {
                    listDiv.style.display = 'block';
                    renderTracksList(tracks);
                }
            })
            .catch(error => {
                console.error('Error loading GPS tracks:', error);
                loadingDiv.style.display = 'none';
                errorDiv.style.display = 'block';
                document.getElementById('tracks-error-message').textContent = 'Failed to load tracks';
                totalCountSpan.textContent = '--';
                storageLocationSpan.textContent = '--';
            });
    }
    
    function renderTracksList(tracks) {
        const listDiv = document.getElementById('tracks-list');
        
        listDiv.innerHTML = tracks.map(track => `
            <div class="track-item">
                <div class="track-header">
                    <div class="track-name">
                        📍 ${track.display_name || track.filename}
                    </div>
                    <div class="track-date">
                        ${track.modified_display}
                    </div>
                </div>
                
                <div class="track-details">
                    <div class="track-detail">
                        <span>🎯</span> ${track.points} points
                    </div>
                    <div class="track-detail">
                        <span>💾</span> ${track.size_mb} MB
                    </div>
                    ${track.username ? `<div class="track-detail"><span>👤</span> ${track.username}</div>` : ''}
                    ${track.vehicle ? `<div class="track-detail"><span>✈️</span> ${track.vehicle}</div>` : ''}
                    ${track.date ? `<div class="track-detail"><span>📅</span> ${track.date}</div>` : ''}
                    ${track.time ? `<div class="track-detail"><span>🕐</span> ${track.time}</div>` : ''}
                </div>
                
                <div class="track-actions">
                    <button class="btn btn-sm btn-outline-primary track-btn" onclick="downloadTrack('${track.filename}')">
                        💾 Download
                    </button>
                    <button class="btn btn-sm btn-outline-info track-btn" onclick="viewTrackDetails('${track.filename}')">
                        👁️ View Details
                    </button>
                    <button class="btn btn-sm btn-outline-danger track-btn" onclick="deleteTrack('${track.filename}')">
                        🗑️ Delete
                    </button>
                </div>
            </div>
        `).join('');
    }
    
    function downloadTrack(filename) {
        // Create a download link for the track file
        window.open(`/download-track/${encodeURIComponent(filename)}`, '_blank');
    }
    
    function viewTrackDetails(filename) {
        // For now, just show an alert with filename
        // This could be expanded to show detailed track information
        alert(`Track Details: ${filename}\n\nThis feature can be expanded to show detailed track information like route map, statistics, etc.`);
    }
    
    function deleteTrack(filename) {
        if (!confirm(`Are you sure you want to delete the track "${filename}"?\n\nThis action cannot be undone.`)) {
            return;
        }
        
        fetch('/delete-track', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename: filename })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                loadGPSTracks(); // Refresh the list
            } else {
                alert(`Failed to delete track: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error deleting track:', error);
            alert('Error deleting track');
        });
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        if (statsPollingInterval) {
            clearInterval(statsPollingInterval);
        }
        if (diagnosticsPollingInterval) {
            clearInterval(diagnosticsPollingInterval);
        }
        if (activeRecordingsPollingInterval) {
            clearInterval(activeRecordingsPollingInterval);
        }
        if (streamingStatusEventSource) {
            streamingStatusEventSource.close();
        }
        if (serviceMonitoringEventSource) {
            serviceMonitoringEventSource.close();
        }
        if (serviceLogEventSource) {
            serviceLogEventSource.close();
        }
    });

        // --- Active Recordings Panel Auto-Refresh ---
        function renderActiveRecordingsPanel(files) {
            let frame = document.getElementById('active-recordings-frame');
            if (!frame) return;
            
            // Show/hide the panel based on streaming status and active files
            if (!streaming) {
                frame.style.display = 'none';
                return;
            }
            
            // Only show if streaming is active
            frame.style.display = '';
            const listDiv = frame.querySelector('#active-recordings-list');
            listDiv.innerHTML = '';
            if (files && files.length > 0) {
                files.forEach((file, idx) => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '0.5em';
                    // Use timestamp from file object directly
                    let durationStr = '--';
                    let bitrateStr = '--';
                    let filesizeStr = '--';
                    if (file.size) {
                        filesizeStr = file.size + ' bytes';
                        if (file.size >= 1024 * 1024) {
                            filesizeStr = (file.size / (1024 * 1024)).toFixed(2) + ' MB';
                        } else if (file.size >= 1024) {
                            filesizeStr = (file.size / 1024).toFixed(2) + ' KB';
                        }
                    }
                    let duration = null;
                    const now = Math.floor(Date.now() / 1000);
                    if (file.timestamp && now > file.timestamp) {
                        duration = now - file.timestamp;
                        durationStr = duration + 's';
                    }
                    // Calculate bitrate as filesize / duration
                    if (duration && duration > 0 && file.size) {
                        const bitrate = Math.round((file.size * 8) / duration / 1000);
                        bitrateStr = `${bitrate} kbps`;
                    }
                    div.innerHTML = `<label style="word-break:break-all;"><b>Active recording:</b> ${file.name}<br>Size: ${filesizeStr}<br>Duration: ${durationStr}<br>Bitrate: ${bitrateStr}<br>Location: ${file.location}</label>`;
                    listDiv.appendChild(div);
                });
            } else if (streaming) {
                const div = document.createElement('div');
                div.style.marginBottom = '0.5em';
                div.innerHTML = '<label>No active recordings yet. Streaming is running...</label>';
                listDiv.appendChild(div);
            }
        }
        let activeRecordingsPollingInterval = null;
        let streamingStatusEventSource = null;

        function startActiveRecordingsRefresh() {
            // Use polling for active recordings
            if (activeRecordingsPollingInterval) {
                clearInterval(activeRecordingsPollingInterval);
            }
            
            // Start polling every 2 seconds (more frequent since recordings change during active use)
            activeRecordingsPollingInterval = setInterval(fetchActiveRecordings, 2000);
            // Fetch immediately on start
            fetchActiveRecordings();
        }
        
        function fetchActiveRecordings() {
            // Only fetch if streaming (since active recordings only matter when streaming)
            if (!streaming) {
                // If streaming stopped, hide the active recordings panel
                const frame = document.getElementById('active-recordings-frame');
                if (frame) {
                    frame.style.display = 'none';
                }
                return; // Skip polling if not streaming
            }
            
            fetch('/active-recordings')
                .then(response => response.json())
                .then(data => {
                    const files = data.files || [];
                    renderActiveRecordingsPanel(files);
                })
                .catch(error => {
                    console.error('Error fetching active recordings:', error);
                    // Don't update UI on error, keep last known values
                });
        }

        function stopActiveRecordingsRefresh() {
            if (activeRecordingsPollingInterval) {
                clearInterval(activeRecordingsPollingInterval);
                activeRecordingsPollingInterval = null;
            }
        }
        
        // Always start the active recordings refresh if streaming is active
        if (streaming) {
            startActiveRecordingsRefresh();
            startStreamingStatusRefresh();
        }        // Streaming status functionality
        function updateStreamStatusWithRelayInfo(relayData) {
            try {
                // Update bitrate
                const bitrateEl = document.getElementById('stream-bitrate');
                if (bitrateEl) {
                    if (relayData.bitrate === 'passthrough') {
                        bitrateEl.textContent = 'Passthrough';
                    } else if (relayData.bitrate === 'initializing') {
                        bitrateEl.textContent = 'Initializing...';
                    } else {
                        bitrateEl.textContent = relayData.bitrate || '--';
                    }
                }

                // Update measured bitrate
                const measuredBitrateEl = document.getElementById('stream-measured-bitrate');
                if (measuredBitrateEl) {
                    if (relayData.measured_bitrate !== undefined && relayData.measured_bitrate > 0) {
                        measuredBitrateEl.textContent = relayData.measured_bitrate;
                    } else {
                        measuredBitrateEl.textContent = '--';
                    }
                }

                // Update network status
                const networkStatusEl = document.getElementById('stream-network-status');
                if (networkStatusEl) {
                    const status = relayData.network_status || 'unknown';
                    networkStatusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    // Apply appropriate styling based on status
                    networkStatusEl.className = 'stat-value connection-status';
                    if (status === 'stable') {
                        networkStatusEl.style.color = '#5cb85c'; // green
                    } else if (status === 'unstable') {
                        networkStatusEl.style.color = '#f0ad4e'; // orange
                    } else if (status === 'congested') {
                        networkStatusEl.style.color = '#d9534f'; // red
                    } else {
                        networkStatusEl.style.color = '';
                    }
                }

                // Update stream health
                const streamHealthEl = document.getElementById('stream-health');
                if (streamHealthEl) {
                    const health = relayData.stream_health || 'unknown';
                    streamHealthEl.textContent = health.charAt(0).toUpperCase() + health.slice(1);
                    // Apply appropriate styling based on health
                    streamHealthEl.className = 'stat-value connection-status';
                    if (health === 'good' || health === 'passthrough') {
                        streamHealthEl.style.color = '#5cb85c'; // green
                    } else if (health === 'degraded') {
                        streamHealthEl.style.color = '#f0ad4e'; // orange
                    } else if (health === 'initializing') {
                        streamHealthEl.style.color = '#5bc0de'; // blue
                    } else {
                        streamHealthEl.style.color = '';
                    }
                }
            } catch (e) {
                console.error('Error updating stream status:', e);
            }
        }

        function startStreamingStatusRefresh() {
            // Use SSE for real-time streaming status updates
            if (streamingStatusEventSource) {
                streamingStatusEventSource.close();
            }
            streamingStatusEventSource = new EventSource('/relay-status-sse');
            streamingStatusEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.status) {
                        const relayData = JSON.parse(data.status);
                        updateStreamStatusWithRelayInfo(relayData);
                    }
                } catch (e) {
                    console.error('Error parsing relay status:', e);
                }
            };
            streamingStatusEventSource.onerror = function() {
                // SSE has terminated, stop the refresh
                stopStreamingStatusRefresh();
                
                // Stop active recordings polling
                stopActiveRecordingsRefresh();
                
                // Hide active recordings panel since streaming stopped
                const activeFrame = document.getElementById('active-recordings-frame');
                if (activeFrame) {
                    activeFrame.style.display = 'none';
                }
                
                // Update streaming state
                streaming = false;
                streamBtn.textContent = 'Start Streaming';
                streamStatus.textContent = 'Streaming is stopped.';
                streamStatus.style.display = '';
                streamStatus.style.color = '';
                streamStatus.style.backgroundColor = '';
                streamStatus.style.padding = '';
                streamStatus.style.borderRadius = '';
                streamStatus.style.fontWeight = '';
                streamBtn.disabled = false;

                // Hide streaming info panel
                const streamingInfoPanel = document.getElementById('streaming-info-panel');
                if (streamingInfoPanel) {
                    streamingInfoPanel.style.display = 'none';
                }
                
                // Update and show the upload recordings list
                updateUploadRecordingsList();
            };
        }

        function stopStreamingStatusRefresh() {
            if (streamingStatusEventSource) {
                streamingStatusEventSource.close();
                streamingStatusEventSource = null;
            }
        }

        // Streaming control
        const streamBtn = document.getElementById('stream-btn');
        const streamStatus = document.getElementById('stream-status');
        streamBtn.addEventListener('click', function () {
            // Remove upload box if present when starting streaming
            if (!streaming) {
                const uploadFrame = document.getElementById('upload-frame');
                if (uploadFrame) uploadFrame.remove();
            }
            streamBtn.disabled = true;
            streamStatus.textContent = streaming ? 'Stopping...' : 'Starting...';
            streamStatus.style.display = '';
            fetch('/stream-control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: streaming ? 'stop' : 'start' })
            })
                .then(r => r.json().then(data => ({ status: r.status, data })))
                .then(result => {
                    if (result.status !== 200 && result.data && result.data.error) {
                        streamStatus.textContent = result.data.error;
                        streamStatus.style.display = '';
                        streamStatus.style.color = '#fff';
                        streamStatus.style.backgroundColor = '#d9534f'; // Bootstrap danger
                        streamStatus.style.padding = '0.5em 1em';
                        streamStatus.style.borderRadius = '6px';
                        streamStatus.style.fontWeight = 'bold';
                        streamBtn.disabled = false;
                        return;
                    }
                    streaming = !streaming;
                    streamBtn.textContent = streaming ? 'Stop Streaming' : 'Start Streaming';
                    streamStatus.textContent = streaming ? 'Streaming is running.' : 'Streaming is stopped.';
                    streamStatus.style.display = '';
                    streamStatus.style.color = '';
                    streamStatus.style.backgroundColor = '';
                    streamStatus.style.padding = '';
                    streamStatus.style.borderRadius = '';
                    streamStatus.style.fontWeight = '';
                    streamBtn.disabled = false;

                    // Show/hide streaming info panel
                    const streamingInfoPanel = document.getElementById('streaming-info-panel');
                    if (streamingInfoPanel) {
                        streamingInfoPanel.style.display = streaming ? 'block' : 'none';
                    }

                    if (streaming) {
                        // Ensure the active recordings panel is visible again
                        const activeFrame = document.getElementById('active-recordings-frame');
                        if (activeFrame) activeFrame.style.display = '';
                        startActiveRecordingsRefresh();
                        startStreamingStatusRefresh();
                    }
                    // Note: Cleanup when streaming stops is now handled by the SSE error handler
                })
                .catch(() => {
                    streamStatus.textContent = 'Error.';
                    streamBtn.disabled = false;
                });
        });

        // Function to update GPS status display
        function updateGPSStatus() {
            if (!gpsTracking) return; // Only update when GPS tracking is active
            
            fetch('/gps-status')
                .then(r => r.json())
                .then(status => {
                    const statusDescription = gpsStatus.querySelector('em');
                    if (!statusDescription) return;
                    
                    // Update status message based on hardware status, using actual status_message
                    if (status.hardware_status === 'active') {
                        statusDescription.innerHTML = `<span style="color: #28a745;">${status.status_message}</span>`;
                    } else if (status.hardware_status === 'connected') {
                        statusDescription.innerHTML = `<span style="color: #ffc107;">${status.status_message}</span>`;
                    } else if (status.hardware_status === 'disconnected') {
                        statusDescription.innerHTML = `<span style="color: #dc3545;">${status.status_message}</span>`;
                    } else if (status.hardware_status === 'error') {
                        statusDescription.innerHTML = `<span style="color: #dc3545;">${status.status_message}</span>`;
                    } else if (status.hardware_status === 'waiting') {
                        statusDescription.innerHTML = `<span style="color: #6c757d;">${status.status_message}</span>`;
                    } else {
                        statusDescription.innerHTML = `<span style="color: #6c757d;">${status.status_message}</span>`;
                    }
                })
                .catch(err => {
                    console.log('GPS status update failed:', err);
                });
        }

        // Update GPS status every 3 seconds when tracking is active
        setInterval(updateGPSStatus, 3000);

        // Service Monitoring functionality
        let serviceMonitoringEventSource = null;
        
        function startServiceMonitoring() {
            if (serviceMonitoringEventSource) {
                serviceMonitoringEventSource.close();
            }
            
            serviceMonitoringEventSource = new EventSource('/service-status-sse');
            
            serviceMonitoringEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateServiceStatus(data);
                } catch (e) {
                    console.error('Error parsing service status data:', e);
                }
            };
            
            serviceMonitoringEventSource.onerror = function() {
                console.error('Service monitoring SSE connection error');
                // Try to reconnect after 5 seconds
                setTimeout(() => {
                    if (serviceMonitoringEventSource.readyState === EventSource.CLOSED) {
                        startServiceMonitoring();
                    }
                }, 5000);
            };
        }
        
        // Store service data globally for when panel becomes visible
        let lastServiceData = null;
        
        function updateServiceStatus(data) {
            // Always store the latest data
            lastServiceData = data;
            
            // Only update UI if service monitoring panel is visible
            const serviceContent = document.getElementById('service-monitoring-content');
            if (serviceContent && serviceContent.classList.contains('collapsed')) {
                return; // Skip UI update if panel is collapsed, but data is still stored
            }
            
            updateServiceStatusUI(data);
        }
        
        function updateServiceStatusUI(data) {
            const services = ['gps-daemon', 'gps-startup', 'mediamtx', 'heartbeat-daemon', 'ups-monitor', 'relay-ffmpeg.py', 'relay-ffmpeg-record.py'];
            const processes = ['relay-ffmpeg.py', 'relay-ffmpeg-record.py']; // Python processes (not systemd services)
            
            services.forEach(service => {
                const element = document.getElementById(`service-${service}`);
                const enableBtn = document.querySelector(`[data-service="${service}"].service-enable-btn`);
                const disableBtn = document.querySelector(`[data-service="${service}"].service-disable-btn`);
                
                if (element) {
                    const status = data[service];
                    if (status) {
                        let displayText = status.status;
                        const isProcess = processes.includes(service);
                        
                        // Handle error cases
                        if (status.error) {
                            if (status.status === 'unavailable') {
                                displayText = 'N/A';
                            } else if (status.status === 'timeout') {
                                displayText = 'Timeout';
                            } else {
                                displayText = 'Error';
                            }
                            element.textContent = displayText;
                        } else {
                            // Create comprehensive status display with icons and separate lines
                            const runningStatus = status.status.charAt(0).toUpperCase() + status.status.slice(1);
                            const bootColor = status.enabled ? '#28a745' : '#dc3545'; // green for enabled, red for disabled
                            const bootStatus = status.enabled ? 'Boot: Enabled' : 'Boot: Disabled';
                            
                            // Choose running status icon and color
                            let runningIcon = '❓';
                            let runningColor = '#6c757d';
                            
                            if (status.status === 'active') {
                                runningIcon = '✅';
                                runningColor = '#28a745';
                            } else if (status.status === 'inactive') {
                                runningIcon = '⭕';
                                runningColor = '#dc3545';
                            } else if (status.status === 'failed' || status.status === 'error') {
                                runningIcon = '❌';
                                runningColor = '#dc3545';
                            } else if (status.status === 'activating') {
                                runningIcon = '🔄';
                                runningColor = '#ffc107';
                            } else if (status.status === 'deactivating') {
                                runningIcon = '⏳';
                                runningColor = '#ffc107';
                            }
                            
                            // Choose boot status icon
                            const bootIcon = status.enabled ? '🚀' : '🚫';
                            
                            // Use innerHTML with different display for services vs processes
                            if (isProcess) {
                                // For processes, only show running status (no boot status)
                                element.innerHTML = `
                                    <div style="line-height: 1.2; text-align: left;">
                                        <div style="color: ${runningColor}; font-weight: bold;">
                                            ${runningIcon} ${runningStatus}
                                        </div>
                                    </div>
                                `;
                            } else {
                                // For services, show both running and boot status
                                element.innerHTML = `
                                    <div style="line-height: 1.2; text-align: left;">
                                        <div style="color: ${runningColor}; font-weight: bold;">
                                            ${runningIcon} ${runningStatus}
                                        </div>
                                        <div style="color: ${bootColor}; font-size: 0.9em; font-weight: normal;">
                                            ${bootIcon} ${bootStatus}
                                        </div>
                                    </div>
                                `;
                            }
                        }
                        
                        // Set class but don't override colors since we handle them inline for multi-line display
                        element.className = 'stat-value connection-status';
                        
                        // For error cases, apply color to the entire element
                        if (status.error) {
                            if (status.status === 'unavailable' || status.status === 'timeout') {
                                element.style.color = '#6c757d'; // gray
                            } else {
                                element.style.color = '#dc3545'; // red
                            }
                        } else {
                            // Reset color for normal cases since we use inline styles
                            element.style.color = '';
                        }
                        
                        // Add tooltip with additional info if available
                        if (status.sub_state && status.sub_state !== 'running' && status.sub_state !== 'unknown') {
                            if (isProcess) {
                                element.title = `Running: ${status.status} | Sub-state: ${status.sub_state}`;
                            } else {
                                element.title = `Running: ${status.status} | Boot: ${status.enabled ? 'Enabled' : 'Disabled'} | Sub-state: ${status.sub_state}`;
                            }
                        } else if (status.error) {
                            element.title = `Error: ${status.error}`;
                        } else {
                            if (isProcess) {
                                element.title = `Running: ${status.status}`;
                            } else {
                                element.title = `Running: ${status.status} | Boot: ${status.enabled ? 'Enabled' : 'Disabled'}`;
                            }
                        }
                        
                        // Show/hide start/stop buttons based on running status
                        if (enableBtn && disableBtn && !status.error && status.status !== 'unavailable') {
                            if (status.status === 'active') {
                                // Service is running - show stop button
                                enableBtn.style.display = 'none';
                                disableBtn.style.display = 'inline-block';
                            } else {
                                // Service is not running - show start button
                                enableBtn.style.display = 'inline-block';
                                disableBtn.style.display = 'none';
                            }
                        } else if (enableBtn && disableBtn) {
                            // Hide both buttons if service is unavailable or has errors
                            enableBtn.style.display = 'none';
                            disableBtn.style.display = 'none';
                        }
                    } else {
                        element.textContent = 'Unknown';
                        element.style.color = '#6c757d'; // gray
                        element.title = '';
                        
                        // Hide enable/disable buttons for unknown services
                        if (enableBtn && disableBtn) {
                            enableBtn.style.display = 'none';
                            disableBtn.style.display = 'none';
                        }
                    }
                }
            });
        }
        
        // Service monitoring is now initialized via combined DOMContentLoaded handler

        // Service Log Viewer functionality
        let serviceLogEventSource = null;
        let logPaused = false;
        let currentService = null;
        
        function initializeLogViewer() {
            const logViewer = document.getElementById('service-log-viewer');
            const logContent = document.getElementById('log-content');
            const logTitle = document.getElementById('log-viewer-title');
            const logStatus = document.getElementById('log-status');
            const logClearBtn = document.getElementById('log-clear-btn');
            const logPauseBtn = document.getElementById('log-pause-btn');
            const logCloseBtn = document.getElementById('log-close-btn');
            
            // Add click handlers for log buttons
            document.querySelectorAll('.service-log-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const service = this.getAttribute('data-service');
                    openServiceLogs(service);
                });
            });
            
            // Add click handlers for enable/disable buttons
            document.querySelectorAll('.service-enable-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const service = this.getAttribute('data-service');
                    enableService(service);
                });
            });
            
            document.querySelectorAll('.service-disable-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const service = this.getAttribute('data-service');
                    disableService(service);
                });
            });
            
            // Clear logs
            logClearBtn.addEventListener('click', function() {
                logContent.innerHTML = '';
            });
            
            // Pause/Resume logs
            logPauseBtn.addEventListener('click', function() {
                logPaused = !logPaused;
                if (logPaused) {
                    logPauseBtn.innerHTML = '▶️ Resume';
                    logStatus.textContent = 'Paused';
                    logStatus.className = 'log-status paused';
                } else {
                    logPauseBtn.innerHTML = '⏸️ Pause';
                    if (serviceLogEventSource && serviceLogEventSource.readyState === EventSource.OPEN) {
                        logStatus.textContent = 'Connected';
                        logStatus.className = 'log-status connected';
                    }
                }
            });
            
            // Close log viewer
            logCloseBtn.addEventListener('click', function() {
                closeServiceLogs();
            });
        }
        
        function enableService(service) {
            if (!confirm(`Enable and start ${service} service? This will start the service now and allow it to start automatically on boot.`)) {
                return;
            }
            
            const enableBtn = document.querySelector(`[data-service="${service}"].service-enable-btn`);
            const disableBtn = document.querySelector(`[data-service="${service}"].service-disable-btn`);
            
            if (enableBtn) {
                enableBtn.disabled = true;
                enableBtn.innerHTML = '⏳ Starting...';
            }
            
            fetch('/service-control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ service: service, action: 'enable' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Success - buttons will be updated by next status poll
                    console.log(`Successfully enabled and started ${service}`);
                } else {
                    alert(`Failed to enable ${service}: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error enabling service:', error);
                alert(`Error enabling ${service}: ${error.message}`);
            })
            .finally(() => {
                if (enableBtn) {
                    enableBtn.disabled = false;
                    enableBtn.innerHTML = '▶️ Start';
                }
            });
        }
        
        function disableService(service) {
            if (!confirm(`Stop and disable ${service} service? This will stop the service now and prevent it from starting automatically on boot.`)) {
                return;
            }
            
            const enableBtn = document.querySelector(`[data-service="${service}"].service-enable-btn`);
            const disableBtn = document.querySelector(`[data-service="${service}"].service-disable-btn`);
            
            if (disableBtn) {
                disableBtn.disabled = true;
                disableBtn.innerHTML = '⏳ Stopping...';
            }
            
            fetch('/service-control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ service: service, action: 'disable' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Success - buttons will be updated by next status poll
                    console.log(`Successfully stopped and disabled ${service}`);
                } else {
                    alert(`Failed to disable ${service}: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error disabling service:', error);
                alert(`Error disabling ${service}: ${error.message}`);
            })
            .finally(() => {
                if (disableBtn) {
                    disableBtn.disabled = false;
                    disableBtn.innerHTML = '⏹️ Stop';
                }
            });
        }
        
        function openServiceLogs(service) {
            currentService = service;
            const logViewer = document.getElementById('service-log-viewer');
            const logContent = document.getElementById('log-content');
            const logTitle = document.getElementById('log-viewer-title');
            const logStatus = document.getElementById('log-status');
            const logPauseBtn = document.getElementById('log-pause-btn');
            
            // Reset state
            logPaused = false;
            logPauseBtn.innerHTML = '⏸️ Pause';
            logContent.innerHTML = '';
            
            // Update title
            logTitle.textContent = `${service} Logs`;
            
            // Show log viewer
            logViewer.style.display = 'block';
            
            // Close existing connection
            if (serviceLogEventSource) {
                serviceLogEventSource.close();
            }
            
            // Start SSE connection for logs
            logStatus.textContent = 'Connecting...';
            logStatus.className = 'log-status';
            
            serviceLogEventSource = new EventSource(`/service-logs-sse/${service}`);
            
            serviceLogEventSource.onopen = function() {
                if (!logPaused) {
                    logStatus.textContent = 'Connected';
                    logStatus.className = 'log-status connected';
                }
            };
            
            serviceLogEventSource.onmessage = function(event) {
                if (logPaused) return;
                
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'log') {
                        appendLogEntry(data.line, data.timestamp);
                    } else if (data.type === 'initial') {
                        // Clear and show initial logs
                        logContent.innerHTML = '';
                        data.lines.forEach(line => {
                            appendLogEntry(line.line, line.timestamp);
                        });
                    } else if (data.type === 'error') {
                        logStatus.textContent = `Error: ${data.message}`;
                        logStatus.className = 'log-status error';
                    }
                } catch (e) {
                    console.error('Error parsing log data:', e);
                }
            };
            
            serviceLogEventSource.onerror = function() {
                if (!logPaused) {
                    logStatus.textContent = 'Connection error';
                    logStatus.className = 'log-status error';
                }
                
                // Try to reconnect after 5 seconds
                setTimeout(() => {
                    if (currentService && serviceLogEventSource.readyState === EventSource.CLOSED) {
                        openServiceLogs(currentService);
                    }
                }, 5000);
            };
        }
        
        function closeServiceLogs() {
            const logViewer = document.getElementById('service-log-viewer');
            
            if (serviceLogEventSource) {
                serviceLogEventSource.close();
                serviceLogEventSource = null;
            }
            
            logViewer.style.display = 'none';
            currentService = null;
            logPaused = false;
        }
        
        function appendLogEntry(line, timestamp) {
            const logContent = document.getElementById('log-content');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            // Detect log level and apply styling
            const lowerLine = line.toLowerCase();
            if (lowerLine.includes('error') || lowerLine.includes('failed') || lowerLine.includes('fatal')) {
                entry.classList.add('error');
            } else if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
                entry.classList.add('warning');
            } else if (lowerLine.includes('info') || lowerLine.includes('starting') || lowerLine.includes('started')) {
                entry.classList.add('info');
            } else if (lowerLine.includes('success') || lowerLine.includes('completed') || lowerLine.includes('ok')) {
                entry.classList.add('success');
            }
            
            // Format timestamp if provided
            let formattedTime = '';
            if (timestamp) {
                const date = new Date(timestamp);
                formattedTime = date.toLocaleTimeString() + ' ';
            }
            
            entry.innerHTML = `<span class="log-timestamp">${formattedTime}</span>${escapeHtml(line)}`;
            logContent.appendChild(entry);
            
            // Auto-scroll to bottom
            logContent.scrollTop = logContent.scrollHeight;
            
            // Limit number of log entries (keep last 1000)
            const entries = logContent.children;
            if (entries.length > 1000) {
                for (let i = 0; i < 100; i++) {
                    logContent.removeChild(entries[0]);
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Log viewer is now initialized via combined DOMContentLoaded handler

        // GPS Tracking control
        const gpsBtn = document.getElementById('gps-btn');
        const gpsStatus = document.getElementById('gps-status');
        var gpsTracking = {{ gps_tracking | tojson | safe }};
        
        gpsBtn.addEventListener('click', function () {
            gpsBtn.disabled = true;
            const statusText = gpsStatus.querySelector('span[class*="status-"]');
            const statusDescription = gpsStatus.querySelector('em');
            
            if (statusText) statusText.textContent = gpsTracking ? 'Stopping...' : 'Starting...';
            if (statusDescription) statusDescription.textContent = gpsTracking ? 'Stopping GPS tracking...' : 'Starting GPS tracking...';
            
            fetch('/gps-control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: gpsTracking ? 'stop' : 'start' })
            })
                .then(r => r.json().then(data => ({ status: r.status, data })))
                .then(result => {
                    if (result.status !== 200 && result.data && result.data.error) {
                        if (statusDescription) {
                            statusDescription.textContent = result.data.error;
                            statusDescription.style.color = '#d9534f';
                        }
                        gpsBtn.disabled = false;
                        return;
                    }
                    gpsTracking = !gpsTracking;
                    gpsBtn.textContent = gpsTracking ? 'Stop GPS Tracking' : 'Start GPS Tracking';
                    
                    if (statusText) {
                        statusText.textContent = gpsTracking ? 'Active' : 'Inactive';
                        statusText.className = gpsTracking ? 'status-active' : 'status-inactive';
                    }
                    if (statusDescription) {
                        if (gpsTracking) {
                            statusDescription.innerHTML = '<span style="color: #6c757d;">GPS tracking starting - checking hardware status...</span>';
                            // Update status immediately and then start periodic updates
                            setTimeout(updateGPSStatus, 1000);
                        } else {
                            statusDescription.textContent = 'Click "Start GPS Tracking" to begin location tracking';
                        }
                        statusDescription.style.color = '';
                    }
                    gpsBtn.disabled = false;
                })
                .catch(() => {
                    if (statusDescription) {
                        statusDescription.textContent = 'Error controlling GPS tracking.';
                        statusDescription.style.color = '#d9534f';
                    }
                    gpsBtn.disabled = false;
                });
        });

        // Add this function after the streaming control logic
        function updateUploadRecordingsList() {
            fetch(window.location.pathname)
                .then(resp => resp.text())
                .then(html => {
                    // Create a temporary DOM to parse the new upload-form
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    const newUploadFrame = tempDiv.querySelector('#upload-frame');
                    const oldUploadFrame = document.getElementById('upload-frame');
                    if (newUploadFrame) {
                        if (oldUploadFrame) {
                            oldUploadFrame.replaceWith(newUploadFrame);
                        } else {
                            // Insert after stream-panel
                            const streamPanel = document.getElementById('stream-panel');
                            streamPanel.parentNode.insertBefore(newUploadFrame, streamPanel.nextSibling);
                        }
                    } else if (oldUploadFrame) {
                        oldUploadFrame.remove();
                    }
                    // Re-initialize upload form JS
                    if (newUploadFrame) {
                        // Re-run the upload form JS logic
                        document.dispatchEvent(new Event('DOMContentLoaded'));
                    }
                });
        }
    </script>
    {% endif %}

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const deleteBtn = document.getElementById('delete-btn');
            const moveToUsbBtn = document.getElementById('move-to-usb-btn');
            const uploadForm = document.getElementById('upload-form');
            const uploadBtn = document.getElementById('upload-btn');
            const uploadResult = document.getElementById('upload-result');
            
            // Move to USB Drive functionality
            if (moveToUsbBtn && uploadForm) {
                moveToUsbBtn.onclick = async function () {
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        uploadResult.innerHTML = '<span style="color:red;">No recordings selected.</span>';
                        return;
                    }
                    
                    if (!confirm('Move selected recordings to USB drive?')) return;
                    
                    moveToUsbBtn.disabled = true;
                    let movedCount = 0;
                    let resultList = uploadResult.querySelector('ul');
                    if (!resultList) {
                        resultList = document.createElement('ul');
                        uploadResult.innerHTML = '';
                        uploadResult.appendChild(resultList);
                    }
                    resultList.innerHTML = '';
                    
                    for (let i = 0; i < checkboxes.length; i++) {
                        const filePath = checkboxes[i].value;
                        const li = document.createElement('li');
                        li.textContent = `Moving ${filePath} to USB... (${i + 1}/${checkboxes.length})`;
                        resultList.appendChild(li);
                        
                        try {
                            const resp = await fetch('/move-to-usb', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ file_path: filePath })
                            });
                            const result = await resp.json();
                            
                            if (resp.ok && !result.error) {
                                li.style.color = 'green';
                                li.textContent = `Moved ${filePath} to USB: ${result.destination || 'Success'}`;
                                movedCount++;
                                const checkboxDiv = checkboxes[i].closest('div');
                                if (checkboxDiv) checkboxDiv.remove();
                            } else {
                                li.style.color = 'red';
                                li.textContent = `Error moving ${filePath}: ${result.error || resp.statusText}`;
                            }
                        } catch (e) {
                            li.style.color = 'red';
                            li.textContent = `Error moving ${filePath}: ${e.message}`;
                        }
                    }
                    
                    if (movedCount > 0) {
                        const summary = document.createElement('li');
                        summary.style.color = 'green';
                        summary.textContent = `Successfully moved ${movedCount} file(s) to USB drive.`;
                        resultList.appendChild(summary);
                    }
                    
                    moveToUsbBtn.disabled = false;
                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                        uploadBtn.remove();
                        moveToUsbBtn.remove();
                        deleteBtn.remove();
                    }
                };
            }
            
            // Delete functionality
            if (deleteBtn && uploadForm) {
                deleteBtn.onclick = async function () {
                    const checkboxes = document.querySelectorAll('.upload-checkbox:checked');
                    if (checkboxes.length === 0) {
                        uploadResult.innerHTML = '<span style="color:red;">No recordings selected.</span>';
                        return;
                    } if (!confirm('Delete selected recordings?')) return;
                    deleteBtn.disabled = true;
                    let deletedCount = 0;
                    let resultList = uploadResult.querySelector('ul');
                    if (!resultList) {
                        resultList = document.createElement('ul');
                        uploadResult.innerHTML = '';
                        uploadResult.appendChild(resultList);
                    }
                    resultList.innerHTML = '';
                    for (let i = 0; i < checkboxes.length; i++) {
                        const filePath = checkboxes[i].value;
                        const li = document.createElement('li');
                        li.textContent = `Deleting ${filePath}... (${i + 1}/${checkboxes.length})`;
                        resultList.appendChild(li);
                        try {
                            const resp = await fetch('/delete-recording', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ file_path: filePath })
                            });
                            const result = await resp.json();
                            if (resp.ok && !result.error) {
                                li.style.color = 'green';
                                li.textContent = `Deleted ${filePath}`;
                                deletedCount++;
                                const checkboxDiv = checkboxes[i].closest('div');
                                if (checkboxDiv) checkboxDiv.remove();
                            } else {
                                li.style.color = 'red';
                                li.textContent = `Error deleting ${filePath}: ${result.error || resp.statusText}`;
                            }
                        } catch (e) {
                            li.style.color = 'red';
                            li.textContent = `Error deleting ${filePath}: ${e.message}`;
                        }
                    }
                    if (deletedCount > 0) {
                        const summary = document.createElement('li');
                        summary.style.color = 'green';
                        summary.textContent = `Successfully deleted ${deletedCount} file(s).`;
                        resultList.appendChild(summary);
                    }
                    deleteBtn.disabled = false;
                    if (document.querySelectorAll('.upload-checkbox').length === 0) {
                        uploadBtn.remove();
                        if (moveToUsbBtn) moveToUsbBtn.remove();
                        deleteBtn.remove();
                    }
                };
            }
        });
    </script>
</body>

</html>